# リンク

https://www.shuwasystem.co.jp/book/9784798044781.html

## 第1章 ハロー・ワールドに触れてみる

## 第2章 printf()の内部動作を追う

- ローカルのプログラムをデバッグするときも、`gdbserver`を使うことで標準出力によるコンソールの表示崩れを避けることができる
- その際に、`target remote`ではなく`target extended-remote`を使うことで、通常のgdbデバッグとおなじ間隔で操作できる
- gdbプロンプトで`monitor exit`とすることで、gdbserver側を終了することができる

## 第3章 Linuxカーネルの処理を探る

- Linuxカーネル実装では、システムコール処理関数名と、システムコール番号名が厳密には一致していない

## 第4章 ライブラリからのシステムコール呼び出し

- （著者の感覚的には）grepで件数を300件ぐらいまで狭めることができれば、あとは目視で探せる
- できる技術者同士が少ない言葉数で意思伝達できるのは、用語を正確に知り正確に使っているためという理由が大きい

## 第5章 main()関数の前と後

- `readelf -a`でEntry Pointを調べることで、カーネルがプログラムを実行する際の最初のアドレスを調べることができる
- `main`関数の第一引数と第二引数は、CPUアーキ依存の`start.S`でスタックに積まれるが、第三引数（環境変数）は、CPUアーキ非依存の`libc-start.c`でスタックに積まれる

## 第6章 標準入出力関数の実装を見る

- 出力先がttyの場合はprintfは行毎にバッファのデータを出力するか、出力先がttyではない場合は行毎には出力しない
- 組み込みをターゲットとした標準ライブラリであるnewlibでは、機能を限定することでサイズを削減し、また確実にビルドできるようにしたnano版の実装も用意されている

## 第7章 コンパイルの手順と仕組み

- 「自身がメインテーマとしている分野に対して、その下層にあってその先は知らなくてもいいとしている部分」のことをOSと呼ぶ
- 汎用システムは、ユーザによるアプリケーションの開発や、他社が開発したアプリケーションの動作を許す
- ディストリビューションはLinuxだけでなくGNUアプリケーション群にも大きく依存しているため、「GNU/Linuxディストリビューション」と呼ぶべきである
- `cpp`コマンドを使うことで、プリプロセッサ機能だけを使って文書整形などを行うことができる
- GNU/Linuxディストリビューションにおいて、カーネルが参照する(linuxの)structの定義と、アプリケーションが参照する(glibcの)structの定義は、別の実体になっている

## 第8章 実行ファイル解析

- ELFフォーマットの定義は`/usr/include/elf.h`にある
- ELFフォーマットに限らず、多くのフォーマットは解析用のヘッダファイルが`/usr/include`以下にインストールされている場合が多いので、フォーマットの仕様を調べたいときにはここを探すといい
  - `cpio.h`, `pcap.h`, `ar.h`など
- x86の機械語では、以下のバイトコードが頻出する。これらが多数出現するときに、x86の機械語かな？とあたりをつけることができる
  - 0x55: `push ebp`
  - 0x90: `nop`
  - 0xc9: `leave`
  - 0xc3: `ret`
- `printf`に渡す文字列を`%08x%08x%08x`のように書き換えることで、スタックの内容をダンプすることができる（`printf()`フォーマットストリング攻撃）
- ELFにおける「セクション」はリンカのためにあり、「セグメント」はローダのためにある
- そのため、実行時に不要な「セクション」を管理する「セクションヘッダ」はファイルの終端にあり、実行時に必要な「セグメント」を管理する「プログラムヘッダ」はファイルの先頭にある
- gccが実行ファイルを生成する際に通常使われる標準のリンカスクリプトは、`ld -verbose`で確認できる
- 共有ライブラリに定義された関数呼び出し
  - まず呼び出された関数に対応する、pltに定義された処理を呼び出す(`printf`の場合は`printf@plt`)
  - pltに定義された処理では、gotを参照して、呼び出した関数に対応するアドレスにジャンプする
  - gotの初期値は、共有ライブラリの実体のアドレスを見つけ、gotに登録する処理のアドレスになっている
  - 二回目以降の呼び出しでは、gotを参照した時点で実体のアドレスが取得できる
  - このような二段呼び出しの仕組みは、共有ライブラリを複数のプロセスから別のアドレスにロードするためにある。

## 第9章 最適化

- 最後に改行コードのある文字列を`printf()`で出力するプログラムは、最適化によって文字列の改行コードが削除された上で、`puts()`に置換される
  - このように、最適化では必要に応じでデータの変更も行われるケースがある

## 第10章 様々な環境と様々なアーキテクチャ

- FreeBSDには、Linuxのエミュレーション機能があるため、Linux向けにビルドされたバイナリをそのまま実行することができる

## 第11章 可変長引数の扱い

- 可変長引数では無制限の数を渡す必要があるので、普段はレジスタ経由で引数を渡すアーキテクチャでも、ある一定の数を越えるとスタック経由になる

## 第12章 解析の集大成-システムコールの切替えを見る

- システムコール呼出は基本的にkernelコンテキストに切り替えられるが、`gettimeofday`のように高頻度でデータを読み出すシステムコールについては、コンテキスト切り替えのオーバヘッドを避けるためにkernel側が事前にマップした共有ライブラリでカーネル側のメモリを参照するVDSOという仕組みが用意されている。
- VDSOで呼び出すべきアドレスは、execveが呼び出された時にenvpの先の引数としてカーネルからスタートアップルーチンに渡される
