# Tidy First?

## Links

[Tidy First?](https://www.oreilly.co.jp//books/9784814400911/)

## イントロダクション

- 処理を変更する前に、乱雑なコードをいつ整頓すべきか
- 乱雑なコードを安全かつ効果的に整頓する方法
- 乱雑なコードの整頓のやめどき
- 整頓がうまくいく仕組み

## 第一部　整頓

### 1. ガード節

- 早期リターンのこと
- 数が多すぎない限り、積極的に早期リターンすることで、事前条件を明白にすべし

### 2. デッドコード

- 消すべし

### 3. シンメトリーを揃える

- 似ているが同一ではないルーチンを探し、同じ部分と違う部分を分離することで、共通点を隠してしまわないようにすべし

### 4. 新しいインターフェイス、古い実装

- 自分が呼びたいインターフェースを呼ぶ
  - 後ろからコーディング
  - テストファースト
  - ヘルパーライブラリ、クラス

### 5. 読む順番

- 読むときに知りたい情報がなるべく早く登場する順番に書く

### 6. 凝集の順番

- 関連する手続き、関数、ファイルは、近くに置く

### 7. 変数宣言と初期化を一緒の場所に移動する

- 型の情報と初期値の情報、さらに変数名の情報を、必要なときに読めるように、宣言と初期化を一緒の場所で行うべき

### 8. 説明変数

- 適切な名前をつけた一時変数に値を保存することで、理解の助けにする

### 9. 説明定数

- 固定値がなにを表しているかを定数の名前で表す
- ただし、たまたま同じリテラルが別の意味で使われる場合は、まとめてはならない

### 10. 明示的なパラメーター

- 関数の引数は、塊でまとめて渡すのではなく、バラバラに渡すことで、実際に使われる値をわかりやすく、テストしやすくする

### 11. ステートメントを小分けにする

- 意味のあるコードブロックとコードブロックの間に、空行を入れることで、読みやすくする

### 12. ヘルパーを抽出する

- 明確な目的をもち、他との相互作用が限られているコードブロックは、ルーチンとして抽出し、目的に合わせた名前を付ける
- インターフェースを作ることで、抽象的に考えるきっかけを得ることができる

### 13. ひとかたまり

- 細かく分割しすぎることで、理解しづらくなることがある
- そのような場合は、一度一塊にしてから、改めて理解しやすいように整理すべきである

### 14. 説明コメント

- ヘッダーコメントには、なぜこのファイルを読むことが役に立つかを書いておく

### 15. 冗長なコメントを削除しよう

- 整頓することによって、コメントが冗長になることもある

## 第二部　管理術

### 16. 分けて整頓する

- 整頓は独立した小規模のプルリクで発行するべき

### 17. 連鎖

- 整頓は連鎖するが、規模が大きくなりすぎないように誘惑をたちきるべし

### 18. バッチサイズ

- 整頓は細かく行うことで統合コストが下がるため、細かく導入すべきだが、一般的にレビューコストがあがってしまうためまとめられることがおおい。それを防ぐために、整頓についてはレビュー不要とする文化にすることが望ましい

### 19. リズム

- 振る舞いの変更の前に、数分から一時間以内の整頓を行う
- 変更箇所は集中するので、それですぐに整頓していないコードに遭遇する確率が減る

### 20. 絡まりを解きほぐす

- コンピュータに命令を伝えることを最速で実現するのではなく、コンピュータに対する命令の意図を他の人に伝えることを最速で実現できるように行動する
- そのためには、試行錯誤の結果、整頓とふるまいの変更がごちゃまぜになった修正を一度破棄し、先に整頓してから、ふるまいを変更するべきである

### 21. 先に整頓、あとに整頓、改めて整頓、整頓しない

- 将来絶対にコードを変更しないのであれば、整頓しない
- ふるまいを変更したあとで、整頓したほうが設計が改善されることに気づいた場合
  - 整頓に必要なコンテキストが少なく、後回しにすることによるコスト増が少ないときは、後日改めて気が向いたときに整頓する
  - そうでないときは、ふるまいの変更後に整頓する
- 整頓することで、設計の理解・ふるまいの変更が簡単になり、整頓コストが償却できることが予めわかっているなら、先に整頓する

## 第三部　理論

### 22. 要素を役立つように関係づける

- ソフトウェア設計とは「要素を役立つように関係づけること」である

- 要素について
  - 境界があり、子要素を含む階層構造を持つ
  - トークン→式→ステートメント→関数→オブジェクト/モジュール→システムという階層がある
  - ソフトウェアでは均質な階層構造を好む

- 関係性について
  - 要素間には呼び出し、公開、待ち受け、参照などの関係性がある
  - 適切な関係性により、要素は相互に利益をもたらす
  - 暗黙の関係性が多すぎると変更が困難になる

- 設計者の役割
  - 要素の作成と削除
  - 関係性の作成と削除
  - 関係性が生み出す利益の増加

- システムの構造は以下で構成される
  - 要素の階層
  - 要素間の関係性
  - その関係性から生まれる利益

### 23. 構造と振る舞い

- ソフトウェアの価値創出方法
  - 現在の振る舞い（入出力ペアと不変条件）
  - 将来実現可能な新しい振る舞い

- 振る舞いと構造の関係
  - 振る舞いは直接的な価値を生む
  - 構造は将来の選択肢(オプショナリティ)を生む
  - 同じ振る舞いでも構造により変更容易性が異なる

- オプショナリティの重要性
  - 環境の不安定性が高いほど価値が増す
  - ソフトウェアは物理的制約が少なく拡張性が高い
  - 変更コストを抑えることで選択肢を維持できる

- 構造投資の課題
  - 振る舞いと比べ効果が見えにくい
  - 投資の十分性や正しさの判断が困難
  - 振る舞いの変更と構造の変更は本質的に異なる

### 24. 経済性：時間価値とオプショナリティ

- お金の本質的な性質
  - プログラミングを通じて金融の基本概念を理解できる
  - お金は「凍った欲望（何かほしいがすぐにほしいわけではない）」を表現する手段である
  - お金の要求はギークな要求より優先される

- お金の2つの重要な性質
  - 時間価値：今日の1ドルは明日の1ドルより価値がある
  - オプショナリティ：不確実な状況ではモノよりオプションが優れている

- 時間価値とオプショナリティのトレードオフ
  - 即時の利益追求は将来のオプションを制限する可能性がある
  - オプション重視は即時の利益を逃す可能性がある
  - ソフトウェア設計ではこの2つの要求の調和が必要である

- 経済性の理解がソフトウェア設計に与える影響
  - 金融の基本概念（NPV(正味現在価値)、オプショングリークス）の重要性
  - お金の性質がソフトウェアの設計判断に影響を与える
  - 経済的な視点が設計戦略の評価基準となる

### 25. お金の時間価値

- お金の価値は時期と確実性に依存する
  - 今日の1ドルは明日の1ドルより価値が高い
  - 使用可能性と投資機会の即時性が価値を高める
  - 不確実性は将来の価値を低下させる

- ソフトウェアシステムの価値評価
  - キャッシュフローによるモデル化が重要
  - 入出金の時期が価値判断に大きく影響する
  - コード量や複雑性より経済的価値が重要

- 時間価値の実践的な意味
  - 即時の利益と将来の支出が望ましい
  - 数分から数時間の規模でも時間価値は存在する
  - 整頓は後回しにして、収益機会を優先する場合がある

- 時間価値の理解の重要性
  - 経済的判断の基礎となる
  - より大規模な投資判断に応用できる
  - オプション価値とのトレードオフを考慮する必要がある

### 26. オプション

- オプションの価値の特徴
  - 将来の実装可能性自体に価値がある
  - ポートフォリオの規模が大きいほど価値が高まる
  - 価値ある振る舞いが多いほどオプション価値が上がる
  - 不確実性が高いほどオプションの価値は増加する

- コールオプションの仕組み
  - 将来の固定価格での購入権利を表す
  - 購入義務は伴わない
  - オプション価格は原資産、価格変動性、期間などで決定される

- ソフトウェア設計への応用
  - 設計は将来の振る舞い変更に対するオプションである
  - 現在の設計は将来の変更オプションに対するプレミアムとなる
  - 変動性が高く長期的な開発ほど価値が高まる
  - 最小限の設計でオプション価値を最大化することが重要である

### 27. オプション vs キャッシュフロー

- ディスカウントキャッシュフローの観点に従い整頓をあとで行うか、オプションの観点で整頓を先に行うかを都度意識的に判断することで、ソフトウェア設計のタイミングやスコープに影響するインセンティブを意識することに慣れ、将来の、より大規模なプロダクトの存続と成功がかかった勝負における判断の練習となる
