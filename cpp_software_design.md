# リンク

https://www.oreilly.co.jp/books/9784814400454/

- [C++略語集](https://quuxplusone.github.io/blog/2019/08/02/the-tough-guide-to-cpp-acronyms/)
- [C++ Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#main)
- [サンプルソースコード](https://github.com/igl42/cpp_software_design/tree/main)

# 設計ガイドライン

- 依存関係を最小化せよ
- 関心を分離せよ
- 継承よりコンポジションを優先せよ
- 既存コードに干渉しない解を優先せよ
- 参照セマンティクスより値セマンティクスを優先せよ

# 1. ソフトウェア設計の技
## ガイドライン１：ソフトウェア設計の重要性を理解する

- ソフトウェア設計は、ソフトウェア開発で最も重要であり、保守のコストに大きく影響する
- ソフトウェア設計とは、ソフトウェアコンポーネント間の依存関係を管理する技である。人工的（技術的）依存関係を最小化し、必要な抽象化を導入し、妥協点を見出すことを目的とする。
- ソフトウェアアーキテクチャには一般的な定義はないが、一般に全体にかかる判断を下すものであり、将来変更するのが最も困難な部分である

## ガイドライン２：将来の変更に備え設計する

- SRP (単一責任の原則)に従い、関心を分離する
  - 読解性を高める
  - 無関係の直行するアスペクトの結合を避け、連鎖的に必要となる変更を減らす
- DRY原則に従い、重複を最小化する
- 将来の変更が確実でなければ、時期尚早な抽象化は避ける
- UMLの定義に従えば、安定している機能が上位、変更が発生しやすい機能が下位となる
  - よく見る図の慣例と異なるので、注意が必要
  - この書籍は、UMLの定義に従っている
- 直行するアスペクトはすべて分離すべき
- バリエーションポイントとは、コードの変更が予想されるアスペクトのこと。ここを切り出すことで、依存関係を排除できる。S

## ガイドライン３：インタフェースを分離し人工的関係性を排除する

- インターフェース分離の原則（ISP）
  - 使いもしないメソッドへの依存など、クライアントに矯正すべきではない
  - ISPはSRPのインターフェースに特化した例
  - 無関係の直行するアスペクトを１インターフェースに集めてしまうことは非常に多いので、重要な例として個別に名前がついている

## ガイドライン４：テスト可用性に備え設計する

- テストは必要不可欠
- テストが必要なprivateメンバ関数は、クラス内で宣言する場所を間違えている
- メンバ関数より、非メンバかつ非friend関数を優先することで、カプセル化を促進し、テスト可用性を高めることができる

## ガイドライン５：拡張に備え設計する

- 開放・閉鎖原則（OCP）のとおり、拡張は容易であるべきで、理想的には単にコードを追加するだけで住むべきであり、他コンポーネントの既存コードを改造するなどはあるべきではない
- コードの追加が容易になるよう、基底クラス、テンプレート、関数オーバーロード、テンプレートの特殊化といった手法を検討する
- C++標準ライブラリは、拡張に備えた設計の大変良いお手本である

# 2. 抽象化の技
## ガイドライン６：抽象化から期待される動作に従う

- LSP（リスコフ置換原則）を守るためには、下記が常に守られることを保証しなければならない
  - 具象クラスでは事前条件を強めてはならない
  - 具象クラスでは事後条件を弱めてはならない
  - 具象クラスのメソッドの戻り型は、共変でなければならない
    - つまり、具象クラスのメソッドの戻り型は、抽象クラスの戻り型と同じかサブタイプでなければならない
    - なぜなら、具象クラスで戻り型をスーパータイプにすることは、事後条件を弱めることになるから
  - 具象クラスのメソッドの引数の型は、反変でなければならない
    - つまり、具象クラスのメソッドの引数の型は、抽象クラスの引数の型と同じかスーパータイプでなければならない
    - なぜなら、具象クラスで引数をサブタイプにすることは、事前条件を強めることになるから
    - ただし、C++ではその場合コンパイルエラーとなる
  - 基底クラスの不変条件は、具象クラスでも維持しなければならない
  - 基底型の例外から派生した例外を除いて、派生型で独自の例外を投げてはならない

- 参考
  - [リスコフの置換原則（LSP）をしっかり理解する](https://qiita.com/yuki153/items/142d0d7a556cab787fad#%E3%82%B7%E3%82%B0%E3%83%8D%E3%83%81%E3%83%A3%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%95%E3%82%A7%E3%82%A4%E3%82%B9%E3%83%AB%E3%83%BC%E3%83%AB)
  - [リスコフの置換原則](https://ja.wikipedia.org/wiki/%E3%83%AA%E3%82%B9%E3%82%B3%E3%83%95%E3%81%AE%E7%BD%AE%E6%8F%9B%E5%8E%9F%E5%89%87#%E6%8C%AF%E3%82%8B%E8%88%9E%E3%81%84%E3%82%B5%E3%83%96%E3%82%BF%E3%82%A4%E3%83%94%E3%83%B3%E3%82%B0)

- ポインタが指す具象クラスの型をdynamic_castなどで判別し、それによって呼び出し側の制御を変えている場合、紛れもなくLSP違反であり、非常に良くない
  - 派生クラスの動作に新たな依存関係を発生させてしまうため

- 抽象化が期待する内容の明確化や、誤解の余地がない表現を明文化することも重要
  - 参考：[C++標準にあるイテレータコンセプトの説明文](https://en.cppreference.com/w/cpp/iterator)

## ガイドライン７：基底クラスとコンセプトの共通性を把握する

- 動的多態性（継承）だけでなく、静的多態性（テンプレート）もLSPの対象である
- 静的多態性を用いる場合も、コンセプト（or C++以前のテンプレート引数名）が期待する内容を明確化しなければならない

## ガイドライン８：オーバーロードセットの意味的要件を理解する

- フリー関数をオーバーロードすることでも、静的多態性を実現できる
- そのため、オーバーロードされるべき関数は、期待を明確化しなければならず、既存の名前や命名規則に従うことで期待する内容を予想しやすくしなければならない
- ADL(Argument Dependent Lookup、[実引数依存の名前探索](https://ja.wikipedia.org/wiki/%E5%AE%9F%E5%BC%95%E6%95%B0%E4%BE%9D%E5%AD%98%E3%81%AE%E5%90%8D%E5%89%8D%E6%8E%A2%E7%B4%A2))を活用することで、フリー関数を任意の型に対して適用可能にすることができる(`std::swap`)

## ガイドライン９：抽象化の所有権に注意する

- 正しいアーキテクチャでは、下位（アプリケーション）の実装詳細が、上位（共通コンポーネント）の抽象化に依存する
- DIP（依存関係逆転の原則）を使うことで、上位が下位を呼び出す場合でも、アーキテクチャ上位で抽象化することが可能になる
- 抽象化を所有（ヘッダの提供など）するのは、上位（共通コンポーネント）でなければならない

## ガイドライン１０：アーキテクチャの文書化を検討する

- アーキテクチャドキュメントは保守や現状確認などの意思疎通をする上で必要不可欠
- アーキテクチャの現状と期待される状態を比較、確認するにはツールを使用する

# 3. デザインパターンの目的
## ガイドライン１１：デザインパターンの目的を把握する

- デザインパターンの名前を通して、開発者同士が考えている設計・目的のコミュニケーションコストを下げる
- デザインパターンは何らかの抽象化を用いて依存関係を軽減する
  - Strategyパターンを使って、Strategy使用者を具象Strategyの実装詳細から分離する
  - Factoryパターンを使って、特定の生成処理を分離する
- 実装パターンとは異なり、特定の実装に限定されない
  - 抽象化の実際の方法は、基底クラスに限らず、テンプレートや関数オーバーロード、なんなら関数ポインタでもよい

## ガイドライン１２：デザインパターンを誤解してはいけない

- デザインパターンは最終目的ではない
- デザインパターンは実装詳細ではない
- デザインパターンで用いる抽象化を実際実現する方法は、継承などの動的多態性でもテンプレート引数などの静的多態性でも状況に適したものを使えば良い

## ガイドライン１３：デザインパターンはどこにもある

- C++17から導入されたPolimorphic Allocatorでは、下記のデザインパターンが使われている
  - Template Methodパターン：`std::pmr::memory_resource`で派生クラス用に`do_allocate`, `do_deallocate`といったインタフェースが用意されている
  - Decoratorパターン：`std::pmr::memory_resource`のコンストラクタにそれ自身を渡すことで、複数のアロケータを階層化できる
  - Adapterパターン：`std::pmr::vector`という型エイリアスで、従来型の静的インターフェースと新しい動的アローケータインターフェースをつなぐ
  - Strategyパターン：`std::pmr`により、外部から`std::vector`などのメモリ割当をカスタマイズできる

- 抽象化、分離、柔軟性と拡張性の向上、どれもデザインパターンをもとにしていることが多い

- 32バイト以下の短い文字列は、SSO (Small String Optimization)いにょってスタック上に文字列を配置するのが一般的な`std::string`の実装である。

## ガイドライン１４：デザインパターン名を用い目的を伝える

- 型の名前に使用したデザインパターンを含めることで、設計の目的を明確にし、コードの読解性を向上するべき

# 4. Visitorパターン
## ガイドライン１５：型または処理の追加に備え設計する

- 手続き型プログラミングで素朴に実装した場合、処理の追加は容易だが、型の追加大変
  - 型を判定するためのswitch文がそこかしこにある
- 動的多態性（継承）を素朴に使えば、型の追加を簡単にすることはできるが、処理の追加は大変になる
  - 追加された処理を実装しなければならない具象クラスがそこかしこにある

- 将来拡張の方向性として、主に型の追加を想定するなら動的多態性を、主に処理の追加を想定するなら手続き型・関数型を優先する
- 静的多態性の場合、型も処理も容易に拡張できる

## ガイドライン１６：処理セットを拡張するにはVisitorパターン

- Visitorパターンは、処理を抽象化したVisitorクラスを用意し、処理要求時にはそのインスタンスを渡すことで、処理の追加を一箇所に集約する
- 古典的Visitorパターンの短所
  - Visitorの処理がほとんど同じでも、`visit()`をすべての具象クラスに対して定義しなければならない
  - `visit()`の返り値を派生クラスでは変更できない
  - 型を追加するときには、Visitorクラスの具象クラスをすべて変更しなければならない
  - 基底クラスに仮想関数`accept()`を加えることが問題となることがある
  - `accept()`が派生クラスに継承されるため、適切なoverrideが漏れると、見つけにくい不具合になる
  - ダブルディスパッチ（一回の処理で仮想関数を２回（`accept()`と`visit()`）呼び出す）になるため、性能面で不利
  - classが細分化されることで、メモリフラグメンテーションのリスクが増え、キャッシュ・最適化されづらくなる
  - classが細分化されることで、見通しが悪くなる

## ガイドライン１７：Visitorパターンの実装には`std::variant`を検討する

- C++17で導入された、`std::variant`を使うことで、古典的Visitorパターンの短所の多くを解決できる
  - 継承や仮想関数がなくなり、それに伴う制約・パフォーマンスの懸念・複雑性を回避できる
  - 暗黙的型変換を使って、`operator()`の処理をまとめて定義できる
- 一方で課題もあるため、それも踏まえて選択する必要がある
  - 型の追加時には、`std::variant`のテンプレート引数の追加と利用箇所の再コンパイル、`operator()`の実装追加が必要
    - 仮に実装追加を忘れた場合、わかりやすいエラーではないが、コンパイルエラーで気付ける
  - サイズが大きく異なる型を`std::variant`に持たせると、メモリを無駄遣いしてしまう
    - 処理速度とのトレードオフになるが、ProxyパターンやBrdigeパターンで回避する選択肢もある
  - `std::variant`は実体を持つため、型の内部情報を利用者に公開し、利用者は内部状態に対する依存を持つことになる
    - すなわち、内部状態変更時に再コンパイルが必要になる
    - 処理速度とのトレードオフになるが、ProxyパターンやBrdigeパターンで回避する選択肢もある

## ガイドライン１８：Acyclic Visitorの性能を把握する

- Acyclic Visitorを使えば、型の拡張にも処理の拡張にも開かれた設計にできる
- ただし、クロスキャストが深刻な性能上のオーバーヘッドを生むことを十分に留意する必要がある

# 5. StrategyパターンとCommandパターン

## ガイドライン１９：処理方法を分離するにはStrategyパターン

- 継承が解となるなることはほとんどない
- VisitorパターンとStrategyパターンの違い
  - Visitorパターンのバリエーションポイントは処理の汎用的な追加。つまり、汎用的な処理の追加を容易にする。その結果、型の追加が容易ではなくなる。
  - Strategyパターンのバリエーションポイントは単一関数の実装詳細。つまり、単一関数の実装パターンの追加を容易にする。そのため、メソッドそのものを追加するためには依然として仮想関数の追加という干渉が必要。

  - Strategyパターンの短所
    - 処理の追加は容易になっていない
    - 早い段階でバリエーションポイントを特定できなければ、大掛かりなリファクタリングが必要。ただし、もちろん必要かどうかわからないのにStrategyパターンをつかうのはNG
    - Strategy一つに付き、一つの処理か小規模な関数グループしか扱えない。DIするクラスもその単位ごとに複数必要になる。
      - もし多数の実装詳細を切り出す場合は、External PolymorphismパターにゃType Erasureパターンを検討すべき

- Strategyパターンは静的多態性（クラステンプレート）でも実装可能。ポリシベースの設計と呼ぶ
  - メリット
    - 値渡しができるため、ポインタの間接参照が減り、性能向上が見込める
  - デメリット
    - インスタンスごとにstrategyを変更できない
    - 実装詳細をヘッダに記述し、公開しなければならない

## ガイドライン２０：継承よりコンポジションを優先する

- 継承を使いすぎてはならない
- 継承により、強い依存関係が生じることを肝に銘じる
  - 不要な場合でも純粋仮装関数の実装を強制する
  - 関数の引数や戻り型についても多くのことが固定される
- 継承がもたらす再利用とは、具象クラス実装における基底クラスのコードの再利用ではなく、基底クラス利用コード実装における具象クラス追加時の再利用である
- 継承ではなくコンポジションを優先する

## ガイドライン２１：処理対象を分離するにはCommandパターン

- 構造としては、StrategyパターンとCommandパターンは同じ
  - Strategyパターンは同じ処理を異なる方法で実装することを抽象化する
    - 例:openglで描画する実装と、openglesで描画する実装を抽象化する
  - Commandパターンは任意の処理内容を抽象化し、処理内容によらず実行できるようにする
    - 例:スレッドプールで実行する処理を抽象化する

- Commandパターンも静的多態性、動的多態性どちらも可能

## ガイドライン２２：参照セマンティクスより値セマンティクスを優先する

- 参照セマンティクスは参照先のライフタイムを強く意識する必要があり未定義動作を簡単に引き起こすためできるだけ避け、意味が明確な値セマンティクスを優先する
- 値セマンティクスの値を使用するにあたって、不要なコピーを避けるために以下のテクニックが使われる
  - コピーの省略([参考](https://cpprefjp.github.io/lang/cpp17/guaranteed_copy_elision.html))
  - ムーブセマンティクス
  - 参照渡し
- `std::span`や`std::string_view`などの参照セマンティクスは、サイン章先のライフタイムに注意が必要なので、関数の引数など短期間の使用に限定し、メンバ変数などには使わない

## ガイドライン２３：StrategyパターンとCommmandパターンの実装には値ベースを優先する

- Strategyパターン、Commandパターンを実装する際、`std::function`を使うことで処理を参照渡しではなく値渡しできるようになり、柔軟性とよみやすさが向上する
- `std::function`には性能上の短所があることを考慮する

# 6. Adapterパターン、Observerパターン、CRTPパターン

## ガイドライン２４：インタフェースを統一するにはAdapterパターン

- Adapterパターンは、互換性を持たない部品を一緒に動作させるためにインターフェースを変換する
- オブジェクトAdapterとクラスAdapterではオブジェクトAdapter（コンポジション）を優先する
- フリー関数に対しては、関数Adapterを使う（例：`std::begin`, `std::end`）
  - ADL ([実引数依存の名前探索](https://ja.wikipedia.org/wiki/%E5%AE%9F%E5%BC%95%E6%95%B0%E4%BE%9D%E5%AD%98%E3%81%AE%E5%90%8D%E5%89%8D%E6%8E%A2%E7%B4%A2))を使ったテクニック
- Adapterパターンは容易に実装を追加できるので、追加するときに期待される動作をよく検討し、LSPから逸脱していないかをよく確認しなければならない

## ガイドライン25:通知を抽象化するにはObserberパターン

- 状態変化通知のためのパターン
- 新規オブザーバーの追加がバリエーションポイント
- 状態を渡すプッシュ型と、変化通知のみ渡すプル型があり、一長一短ある
- ここでもセマンティクスベースを優先する

## ガイドライン２６：型を静的に区別するにはCRTPパターン

- CRTPとは、Curiosly Recurring Template Pattern (奇妙に再起したテンプレートパターン)の略だが、これだけだと意味はわからないので気にしなくて良い
- CRTPパターンは性能を低下させない
- すべてのテンプレート引数にはコンセプトを指定すべき。もしまだC++20未対応の環境の場合、enable_ifで同様の制約を課すべき
- テンプレートをインスタンス化する際、引数に与える型は宣言されていれば完全に定義されていなくても構わない
- CRTPパターンを使うときのテンプレート引数名は、`Derived`が望ましい
- パフォーマンス観点で仮想関数を排除するためには、基底クラスのデストラクタはprotectedの非仮想関数としなければならない。その場合、ムーブは非サポートにしなければならない。
- 基底クラスのメソッド定義における戻り値の型は、具象クラスがまだその時点で不完全型のため、直接ネストした型を使えない。`decltype(auto)`で型推論する。
  - `auto`の場合、参照を返すためには`auto&`としなければならない。しかし、ベクトルの零元のように、値(0)を返したいケースでは`auto`にしなければならない。
  - `decltype(auto)`としておけば、値を返すケースも参照を返すケースもどちらも動作する。
  - https://cpprefjp.github.io/lang/cpp14/decltype_auto.html
- CRTPパターンの短所
  - 共通する基底クラスがない
  - 関数テンプレートなので、定義をヘッダに移動する必要がある
  - CRTP基底クラスから派生しなければならないので、外部のクラスに対して使用することはできない
- C++20が使える環境であれば、conceptを優先して使う

## ガイドライン２７：静的mixinクラスにはCRTPパターン

- 処理を注入するmixin基底クラスを実装するときには、CRTPパターンが使える
- mixinのケースでは、CRTP基底クラスをprivateに継承する

# 7. Bridgeパターン、Prototypeパターン、External Polymorphismパターン

## ガイドライン２８：物理的依存関係を排除するにはBridgeパターン

- Bridgeパターンはメンバ変数などの実装詳細を依存先から隠蔽するためのパターン
- pimlイディオムは、ローカルで多態性を持たない形のBridgeパターン
- `pimpl_`メンバ変数を`std::unique_ptr`にしても、デストラクタでは手動でのメモリ解放が必要

- StrategyパターンとBridgeパターンの見分け方
  - 実装詳細を外部から得る場合（コンストラクタ引数やsetterメソッド）はStrategyパターン
  - 実装詳細を外部から受け取る術を用意しておらず、内部で設定していれば、Bridgeパターン

- Bridgeパターンのデメリット
  - pimplポインタ経由の関節参照による性能オーバーヘッド
  - 仮想関数コールの性能オーバーヘッド
  - メンバ関数がインライン展開されなくなることによる性能オーバーヘッド
  - インスタンス生成時の動的メモリ割当の性能オーバーヘッド
  - メモリオーバーヘッド

## ガイドライン２９：Bridgeパターンの性能向上・低下には要注意

- Bridgeパターンは性能を低下させうる
- あまり使用されないデータのみBridgeすることで、性能の低下を限定、あるいはむしろ向上させることもある
- 性能に関しては、勘に頼らずベンチマーク測定を常に確認する

## ガイドライン３０：コピー演算を抽象化するにはPrototypeパターン

- Prototypeパターンは、生成すべきオブジェクトの種類を原型となるインスタンスを使って明確にし、それをコピーすることで新たなオブジェクトの生成を行う
- 参照セマンティクスの解しかなく、値セマンティクスの解はない

- デメリット
  - 関節参照によるパフォーマンスへの悪影響
  - 動的メモリ確保によるフラグメンテーション・性能低下

- コピーコンストラクタ、コピー代入演算子は、常に存在する
  - `=delete`も定義の一つ

## ガイドライン３１：干渉しない実行時多態を実現するにはExternal Polymorphismパターン

- 長所
  - **任意の型**に対して、既存コードに干渉せず、多態動作を追加できる
    - OCPを完全遵守
  - SRPに従っている
  - 継承によるコードの重複を排除できる（DRY）
  - クラステンプレートを使うため、関節参照をごく少なくできる

- 短所
  - クラス構造が複雑
  - 値セマンティクスではない
  - 実装が複雑、という短所についてはガイドライン３２で解決

- 注意点
  - 簡単になんでも抽象化できてしまうが、適切に抽象化するために、ちゃんとISP/LSP遵守するよう熟慮が必要

- Adapterパターンとの違い
  - Adapterパターンは、インターフェースの変換が目的
  - External Polymorphismパターンは、既存の一連の型を多態的に扱うことが目的

# 8. Type Erasureパターン
## ガイドライン３２：Type Erasureパターンで継承階層の置換を検討する

- Type Erasureパターン
  - 固定された処理セットを持つ型の新規追加を容易にする目的を持つデザインパターン
  - External Polymorphismパターンの値セマンティクスベースの実装

- 目的
  - 次の性質を持つ拡張可能な型セットを対象に、既存コードに鑑賞せず値ベースに抽象化する
    - コピー可能、ムーブ可能、推論可能な値型
    - ただし、二項演算には対応しない（状況によって対応は可能だが、複雑でコストがかかる）
    - 継承を強制しない
    - 意味的に同一動作。要件を満たさない型はコンパイルエラー
    - 要件となる動作を持つ既存の方は、修正無しで追加可能

- 短所
  - 実装が複雑
    - 言語仕様に追加するべきという意見もある

## ガイドライン３３：Type Erasureパターンの最適化の余地を認識する

- SBO (Small Buffer Optimization)で、動的メモリ割り当てにかかるオーバーヘッドを軽減できる
  - `alignas(T) std::array`で適切にアラインメントした配列を定義することができる。
  - `reinterpret_cast`は一般にリスクがあるが、この場合に限っては安全
    - 安全だとは思うが、参照先リンクとの関連はわからなかった
    - https://eel.is/c++draft/basic.lval#11
  - 特定のメモリにインスタンスを作るとき、C++20の`std::construct_at`を使うことで、配置newより簡潔にコードが書ける
  - `std::construct_at`により手動でインスタンスを作成する場合、デストラクタも`std::destroy_at`などを使って明示的に呼び出さなければならない

- 仮想関数ディスパッチを手動で実装することで、間接参照の回数を半減することができる

## ガイドライン３４：所有権を持つType Erasureラッパクラスのセットアップコストを意識する

- ガイドライン３２・３３のType Erasureの実装は、所有権を持つため、セットアップ時にコピー演算とメモリ割当が発生する場合がある
- 所有権を持たないType Erasureパターンも可能だが、参照セマンティクス一般の短所を持つ
- Type Erasureパターンの基本実装を優先する。しかし、性能上のデメリットを把握しておく必要がある
- 関数に渡す引数には所有権を持たないType Erasureパターンを優先する。しかし、メンバ変数や戻り型には使用しない

# 9. Decoratorパターン

## ガイドライン３５：カスタマイズを階層化するにはDecoratorパターン

- Decoratorパターンは、オブジェクトに責任を動的に追加する。サブクラス化よりも柔軟な機能拡張方法を提供する

- 利点
  - SRP OK（カスタマイズ必須部分を分離している）
  - OCP OK (価格変更要因の追加に開いていて、他の価格変更要因の改造に閉じている)
  - DRY OK（価格変更要因を容易に再利用し組み合わせられる）
  - デフォルト動作のときに特別なことをしなくて良い（decorateしなければ良い）

- 具体例
  - `std::pmr::monotonic_buffer_resource`
  - C++17のSTLアロケータ

- Adapterパターンとの比較
  - Adapterパターンは別のインターフェースへの変換が目的
  - Decoratorはインターフェースは変更せず、追加・拡張する機能を組み合わせるのが目的。

- Strategyとの比較
  - Strategyは異なる実装を切り替えるのが目的
  - Decoratorは追加・拡張する機能を組み合わせるのが目的

- 短所
  - 性能
  - 複数のDecoratorを誤って組み合わせてしまうリスクがある
  - 参照セマンティクス

## ガイドライン３６：実行時抽象化とコンパイル時抽象化間のトレードオフを理解する

- Decoratorパターンも参照セマンティクスではなく、値セマンティクスで実装でき、そちらを優先すべき

- 値セマンティクスのDecoratorパターンには、コンパイル時Decoratorと、実行時Decoratorの２種類のアプローチがある

- コンパイル時Decoratorパターン
  - メリット：優れた実行性能
  - デメリット：実行時の柔軟性が低い。実装詳細を公開しなければならない
- 実行時Decoratorパターン
  - メリット：実行時の柔軟性が高い。実装詳細が隠蔽できる
  - デメリット：実行性能では劣る

# 10. Singletonパターン

## ガイドライン３７：Singletonパターンはデザインパターンではなく実装パターンとみなす

- Singletonパターンは依存関係を軽減しないし、抽象化もしないので、デザインパターンではない
- 特定のクラスのインスタンス数を厳密に１つに制限するのがSigletonパターンの目的
  - 間違っても、どこからでも誰でも無秩序に読み書きできるようにするために使うものではない

## ガイドライン３８：Singletonパターンに変更しやすさとテスト可用性を設計する

- Singletonパターンのデメリット
  - 依存関係を新たに発生させ、変更しやすさとテスト可用性を損なう
  - グローバルな状態を操作していることが分かりづらい

- グローバルアスペクトをSingletonパターンを使う場合
  - read/writeのどちらかに限定する
  - 静的ローカル変数とIILEを使ったStrategyパターンでDI可能にして、テストできるようにする

# 11. 最後のガイドライン
## ガイドライン 39:デザインパターンの習得は継続すること
- 設計のポイント
  - 依存関係の最小化
    - 人工的に発生する依存関係を削減するために、デザインパターンを活用する
  - 関心の分離
    - 関心の分離により、理解しやすく、変更やテストを容易にする
  - 継承よりもコンポジションを優先する
  - 既存コードに干渉しない設計を優先する
  - 参照セマンティクスより値セマンティクスを優先する
    - c++は値セマンティクスに真摯に取り組んでおり、それに従うことで大きな恩恵を享受できる

- 現場で使用されているデザインパターンを見つけ、実体験を積む。

