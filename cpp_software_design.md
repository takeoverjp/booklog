# リンク

https://www.oreilly.co.jp/books/9784814400454/

- [C++略語集](https://quuxplusone.github.io/blog/2019/08/02/the-tough-guide-to-cpp-acronyms/)
- [C++ Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#main)

# 1. ソフトウェア設計の技
## ガイドライン１：ソフトウェア設計の重要性を理解する

- ソフトウェア設計は、ソフトウェア開発で最も重要であり、保守のコストに大きく影響する
- ソフトウェア設計とは、ソフトウェアコンポーネント間の依存関係を管理する技である。人工的（技術的）依存関係を最小化し、必要な抽象化を導入し、妥協点を見出すことを目的とする。
- ソフトウェアアーキテクチャには一般的な定義はないが、一般に全体にかかる判断を下すものであり、将来変更するのが最も困難な部分である

## ガイドライン２：将来の変更に備え設計する

- SRP (単一責任の原則)に従い、関心を分離する
  - 読解性を高める
  - 無関係の直行するアスペクトの結合を避け、連鎖的に必要となる変更を減らす
- DRY原則に従い、重複を最小化する
- 将来の変更が確実でなければ、時期尚早な抽象化は避ける

## ガイドライン３：インタフェースを分離し人工的関係性を排除する

- 使いもしないメソッドへの依存など、クライアントに矯正すべきではない

## ガイドライン４：テスト可用性に備え設計する

- テストは必要不可欠
- テストが必要なprivateメンバ関数は、クラス内で宣言する場所を間違えている
- メンバ関数より、非メンバかつ非friend関数を優先することで、カプセル化を促進し、テスト可用性を高めることができる

## ガイドライン５：拡張に備え設計する

- 開放・閉鎖原則（OCP）のとおり、拡張は容易であるべきで、理想的には単にコードを追加するだけで住むべきであり、他コンポーネントの既存コードを改造するなどはあるべきではない
- コードの追加が容易になるよう、基底クラス、テンプレート、関数オーバーロード、テンプレートの特殊化といった手法を検討する
- C++標準ライブラリは、拡張に備えた設計の大変良いお手本である

# 2. 抽象化の技
## ガイドライン６：抽象化から期待される動作に従う

- LSP（リスコフ置換原則）を守るためには、下記が常に守られることを保証しなければならない
  - 具象クラスでは事前条件を強めてはならない
  - 具象クラスでは事後条件を弱めてはならない
  - 具象クラスのメソッドの戻り型は、共変でなければならない
    - つまり、具象クラスをそのまま返せなければならない
  - 具象クラスのメソッドの引数の型は、反変でなければならない
    - つまり、基底クラスをそのまま入力にできなければならない
  - 基底クラスの不変条件は、具象クラスでも維持しなければならない

- ポインタが指す具象クラスの型をdynamic_castなどで判別し、それによって呼び出し側の制御を変えている場合、紛れもなくLSP違反であり、非常に良くない
  - 派生クラスの動作に新たな依存関係を発生させてしまうため

- 抽象化が期待する内容の明確化や、誤解の余地がない表現を明文化することも重要
  - 参考：[C++標準にあるイテレータコンセプトの説明文](https://en.cppreference.com/w/cpp/iterator)

## ガイドライン７：基底クラスとコンセプトの共通性を把握する

- 動的多態性（継承）だけでなく、静的多態性（テンプレート）もLSPの対象である
- 静的多態性を用いる場合も、コンセプト（or C++以前のテンプレート引数名）が期待する内容を明確化しなければならない

## ガイドライン８：オーバーロードセットの意味的要件を理解する

- フリー関数をオーバーロードすることでも、静的多態性を実現できる
- そのため、オーバーロードされるべき関数は、期待を明確化しなければならず、既存の名前や命名規則に従うことで期待する内容を予想しやすくしなければならない

## ガイドライン９：抽象化の所有権に注意する

- 正しいアーキテクチャでは、下位（アプリケーション）の実装詳細が、上位（共通コンポーネント）の抽象化に依存する
- DIP（依存関係逆転の原則）を使うことで、上位が下位を呼び出す場合でも、アーキテクチャ上位で抽象化することが可能になる
- 抽象化を所有（ヘッダの提供など）するのは、上位（共通コンポーネント）でなければならない

## ガイドライン１０：アーキテクチャの文書化を検討する

- アーキテクチャドキュメントは保守や現状確認などの意思疎通をする上で必要不可欠
- アーキテクチャの現状と期待される状態を比較、確認するにはツールを使用する

# 3. デザインパターンの目的
## ガイドライン１１：デザインパターンの目的を把握する

- デザインパターンの名前を通して、開発者同士が考えている設計・目的のコミュニケーションコストを下げる
- デザインパターンは何らかの抽象化を用いて依存関係を軽減する
  - Strategyパターンを使って、Strategy使用者を具象Strategyの実装詳細から分離する
  - Factoryパターンを使って、特定の生成処理を分離する
- 実装パターンとは異なり、特定の実装に限定されない
  - 抽象化の実際の方法は、基底クラスに限らず、テンプレートや関数オーバーロード、なんなら関数ポインタでもよい

## ガイドライン１２：デザインパターンを誤解してはいけない

- デザインパターンは最終目的ではない
- デザインパターンは実装詳細ではない
- デザインパターンで用いる抽象化を実際実現する方法は、継承などの動的多態性でもテンプレート引数などの静的多態性でも状況に適したものを使えば良い

## ガイドライン１３：デザインパターンはどこにもある

- C++17から導入されたPolimorphic Allocatorでは、下記のデザインパターンが使われている
  - Template Methodパターン：`std::pmr::memory_resource`で派生クラス用に`do_allocate`, `do_deallocate`といったインタフェースが用意されている
  - Decoratorパターン：`std::pmr::memory_resource`のコンストラクタにそれ自身を渡すことで、複数のアロケータを階層化できる
  - Adapterパターン：`std::pmr::vector`という型エイリアスで、従来型の静的インターフェースと新しい動的アローケータインターフェースをつなぐ
  - Strategyパターン：`std::pmr`により、外部から`std::vector`などのメモリ割当をカスタマイズできる

- 抽象化、分離、柔軟性と拡張性の向上、どれもデザインパターンをもとにしていることが多い

- 32バイト以下の短い文字列は、SSO (Small String Optimization)いにょってスタック上に文字列を配置するのが一般的な`std::string`の実装である。

## ガイドライン１４：デザインパターン名を用い目的を伝える

- 型の名前に使用したデザインパターンを含めることで、設計の目的を明確にし、コードの読解性を向上するべき

# 4. Visitorパターン
## ガイドライン１５：型または処理の追加に備え設計する

- 手続き型プログラミングで素朴に実装した場合、処理の追加は容易だが、型の追加大変
  - 型を判定するためのswitch文がそこかしこにある
- 動的多態性（継承）を素朴に使えば、型の追加を簡単にすることはできるが、処理の追加は大変になる
  - 追加された処理を実装しなければならない具象クラスがそこかしこにある

- 将来拡張の方向性として、主に型の追加を想定するなら動的多態性を、主に処理の追加を想定するなら手続き型・関数型を優先する
- 静的多態性の場合、型も処理も容易に拡張できる

## ガイドライン１６：処理セットを拡張するにはVisitorパターン

- Visitorパターンは、処理を抽象化したVisitorクラスを用意し、処理要求時にはそのインスタンスを渡すことで、処理の追加を一箇所に集約する
- 古典的Visitorパターンの短所
  - Visitorの処理がほとんど同じでも、`visit()`をすべての具象クラスに対して定義しなければならない
  - `visit()`の返り値を派生クラスでは変更できない
  - 型を追加するときには、Visitorクラスの具象クラスをすべて変更しなければならない
  - 基底クラスに仮想関数`accept()`を加えることが問題となることがある
  - `accept()`が派生クラスに継承されるため、適切なoverrideが漏れると、見つけにくい不具合になる
  - ダブルディスパッチ（一回の処理で仮想関数を２回（`accept()`と`visit()`）呼び出す）になるため、性能面で不利
  - classが細分化されることで、メモリフラグメンテーションのリスクが増え、キャッシュ・最適化されづらくなる
  - classが細分化されることで、見通しが悪くなる

## ガイドライン１７：Visitorパターンの実装には`std::variant`を検討する

- C++17で導入された、`std::variant`を使うことで、古典的Visitorパターンの短所の多くを解決できる
  - 継承や仮想関数がなくなり、それに伴う制約・パフォーマンスの懸念・複雑性を回避できる
  - 暗黙的型変換を使って、`operator()`の処理をまとめて定義できる
- 一方で課題もあるため、それも踏まえて選択する必要がある
  - 型の追加時には、`std::variant`のテンプレート引数の追加と利用箇所の再コンパイル、`operator()`の実装追加が必要
    - 仮に実装追加を忘れた場合、わかりやすいエラーではないが、コンパイルエラーで気付ける
  - サイズが大きく異なる型を`std::variant`に持たせると、メモリを無駄遣いしてしまう
    - 処理速度とのトレードオフになるが、ProxyパターンやBrdigeパターンで回避する選択肢もある
  - `std::variant`は実体を持つため、型の内部情報を利用者に公開し、利用者は内部状態に対する依存を持つことになる
    - すなわち、内部状態変更時に再コンパイルが必要になる
    - 処理速度とのトレードオフになるが、ProxyパターンやBrdigeパターンで回避する選択肢もある

## ガイドライン１８：Acyclic Visitorの性能を把握する

- Acyclic Visitorを使えば、型の拡張にも処理の拡張にも開かれた設計にできる
- ただし、クロスキャストが深刻な性能上のオーバーヘッドを生むことを十分に留意する必要がある

# 5. StrategyパターンとCommandパターン

## ガイドライン１９：処理方法を分離するにはStrategyパターン

- 継承が解となるなることはほとんどない
- VisitorパターンとStrategyパターンの違い
  - Visitorパターンのバリエーションポイントは処理の汎用的な追加。つまり、汎用的な処理の追加を容易にする。その結果、型の追加が容易ではなくなる。
  - Strategyパターンのバリエーションポイントは単一関数の実装詳細。つまり、単一関数の実装パターンの追加を容易にする。そのため、メソッドそのものを追加するためには依然として仮想関数の追加という干渉が必要。

  - Strategyパターンの短所
    - 処理の追加は容易になっていない
    - 早い段階でバリエーションポイントを特定できなければ、大掛かりなリファクタリングが必要。ただし、もちろん必要かどうかわからないのにStrategyパターンをつかうのはNG
    - Strategy一つに付き、一つの処理か小規模な関数グループしか扱えない。DIするクラスもその単位ごとに複数必要になる。
      - もし多数の実装詳細を切り出す場合は、External PolymorphismパターにゃType Erasureパターンを検討すべき

- Strategyパターンは静的多態性（クラステンプレート）でも実装可能。ポリシベースの設計と呼ぶ
  - メリット
    - 値渡しができるため、ポインタの間接参照が減り、性能向上が見込める
  - デメリット
    - インスタンスごとにstrategyを変更できない
    - 実装詳細をヘッダに記述し、公開しなければならない

## ガイドライン２０：継承よりコンポジションを優先する

- 継承を使いすぎてはならない
- 継承により、強い依存関係が生じることを肝に銘じる
  - 不要な場合でも純粋仮装関数の実装を強制する
  - 関数の引数や戻り型についても多くのことが固定される
- 継承がもたらす再利用とは、具象クラス実装における基底クラスのコードの再利用ではなく、基底クラス利用コード実装における具象クラス追加時の再利用である
- 継承ではなくコンポジションを優先する

## ガイドライン２１：処理対象を分離するにはCommandパターン

- 構造としては、StrategyパターンとCommandパターンは同じ
  - Strategyパターンは同じ処理を異なる方法で実装することを抽象化する
    - 例:openglで描画する実装と、openglesで描画する実装を抽象化する
  - Commandパターンは任意の処理内容を抽象化し、処理内容によらず実行できるようにする
    - 例:スレッドプールで実行する処理を抽象化する

- Commandパターンも静的多態性、動的多態性どちらも可能

## ガイドライン２２：参照セマンティクスより値セマンティクスを優先する

- 参照セマンティクスは参照先のライフタイムを強く意識する必要があり未定義動作を簡単に引き起こすためできるだけ避け、意味が明確な値セマンティクスを優先する
- 値セマンティクスの値を使用するにあたって、不要なコピーを避けるために以下のテクニックが使われる
  - コピーの省略([参考](https://cpprefjp.github.io/lang/cpp17/guaranteed_copy_elision.html))
  - ムーブセマンティクス
  - 参照渡し
- `std::span`や`std::string_view`などの参照セマンティクスは、サイン章先のライフタイムに注意が必要なので、関数の引数など短期間の使用に限定し、メンバ変数などには使わない

## ガイドライン２３：StrategyパターンとCommmandパターンの実装には値ベースを優先する

- Strategyパターン、Commandパターンを実装する際、`std::function`を使うことで処理を参照渡しではなく値渡しできるようになり、柔軟性とよみやすさが向上する
- `std::function`には性能上の短所があることを考慮する

# 6. Adapterパターン、Observerパターン、CRTPパターン

## ガイドライン２４：インタフェースを統一するにはAdapterパターン

- Adapterパターンは、互換性を持たない部品を一緒に動作させるためにインターフェースを変換する
- オブジェクトAdapterとクラスAdapterではオブジェクトAdapter（コンポジション）を優先する
- フリー関数に対しては、関数Adapterを使う（例：`std::begin`, `std::end`）
  - ADL ([実引数依存の名前探索](https://ja.wikipedia.org/wiki/%E5%AE%9F%E5%BC%95%E6%95%B0%E4%BE%9D%E5%AD%98%E3%81%AE%E5%90%8D%E5%89%8D%E6%8E%A2%E7%B4%A2))を使ったテクニック
- Adapterパターンは容易に実装を追加できるので、追加するときに期待される動作をよく検討し、LSPから逸脱していないかをよく確認しなければならない

## ガイドライン25:通知を抽象化するにはObserberパターン

- 状態変化通知のためのパターン
- 新規オブザーバーの追加がバリエーションポイント
- 状態を渡すプッシュ型と、変化通知のみ渡すプル型があり、一長一短ある
- ここでもセマンティクスベースを優先する

## ガイドライン２６：型を静的に区別するにはCRTPパターン

- CRTPとは、Curiosly Recurring Template Pattern (奇妙に再起したテンプレートパターン)の略だが、これだけだと意味はわからないので気にしなくて良い
- CRTPパターンは性能を低下させない
- すべてのテンプレート引数にはコンセプトを指定すべき。もしまだC++20未対応の環境の場合、enable_ifで同様の制約を課すべき
- テンプレートをインスタンス化する際、引数に与える型は宣言されていれば完全に定義されていなくても構わない
- CRTPパターンを使うときのテンプレート引数名は、`Derived`が望ましい
- パフォーマンス観点で仮想関数を排除するためには、基底クラスのデストラクタはprotectedの非仮想関数としなければならない。その場合、ムーブは非サポートにしなければならない。
- 基底クラスのメソッド定義における戻り値の型は、具象クラスがまだその時点で不完全型のため、直接ネストした型を使えない。`decltype(auto)`で型推論する。
  - `auto`の場合、参照を返すためには`auto&`としなければならない。しかし、ベクトルの零元のように、値(0)を返したいケースでは`auto`にしなければならない。
  - `decltype(auto)`としておけば、値を返すケースも参照を返すケースもどちらも動作する。
  - https://cpprefjp.github.io/lang/cpp14/decltype_auto.html
- CRTPパターンの短所
  - 共通する基底クラスがない
  - 関数テンプレートなので、定義をヘッダに移動する必要がある
  - CRTP基底クラスから派生しなければならないので、外部のクラスに対して使用することはできない
- C++20が使える環境であれば、conceptを優先して使う

## ガイドライン２７：静的mixinクラスにはCRTPパターン

- 処理を注入するmixin基底クラスを実装するときには、CRTPパターンが使える
- mixinのケースでは、CRTP基底クラスをprivateに継承する

# 7. Bridgeパターン、Prototypeパターン、External Polymorphismパターン

## ガイドライン２８：物理的依存関係を排除するにはBridgeパターン

- Bridgeパターンはメンバ変数などの実装詳細を依存先から隠蔽するためのパターン
- pimlイディオムは、ローカルで多態性を持たない形のBridgeパターン
- `pimpl_`メンバ変数を`std::unique_ptr`にしても、デストラクタでは手動でのメモリ解放が必要

- StrategyパターンとBridgeパターンの見分け方
  - 実装詳細を外部から得る場合（コンストラクタ引数やsetterメソッド）はStrategyパターン
  - 実装詳細を外部から受け取る術を用意しておらず、内部で設定していれば、Bridgeパターン

- Bridgeパターンのデメリット
  - pimplポインタ経由の関節参照による性能オーバーヘッド
  - 仮想関数コールの性能オーバーヘッド
  - メンバ関数がインライン展開されなくなることによる性能オーバーヘッド
  - インスタンス生成時の動的メモリ割当の性能オーバーヘッド
  - メモリオーバーヘッド

## ガイドライン２９：Bridgeパターンの性能向上・低下には要注意

- Bridgeパターンは性能を低下させうる
- あまり使用されないデータのみBridgeすることで、性能の低下を限定、あるいはむしろ向上させることもある
- 性能に関しては、感に頼らずベンチマーク測定を常に確認する
