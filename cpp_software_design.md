# リンク

https://www.oreilly.co.jp/books/9784814400454/

# 1. ソフトウェア設計の技
## ガイドライン１：ソフトウェア設計の重要性を理解する

- ソフトウェア設計は、ソフトウェア開発で最も重要であり、保守のコストに大きく影響する
- ソフトウェア設計とは、ソフトウェアコンポーネント間の依存関係を管理する技である。人工的（技術的）依存関係を最小化し、必要な抽象化を導入し、妥協点を見出すことを目的とする。
- ソフトウェアアーキテクチャには一般的な定義はないが、一般に全体にかかる判断を下すものであり、将来変更するのが最も困難な部分である

## ガイドライン２：将来の変更に備え設計する

- SRP (単一責任の原則)に従い、関心を分離し、無関係の直行するアスペクトの結合を避け、連鎖的に必要となる変更を減らす
- DRY原則に従い、重複を最小化する
- 将来の変更が確実でなければ、時期尚早な抽象化は避ける

## ガイドライン３：インタフェースを分離し人工的関係性を排除する

- 使いもしないメソッドへの依存など、クライアントに矯正すべきではない

## ガイドライン４：テスト可用性に備え設計する

- テストは必要不可欠
- テストが必要なprivateメンバ関数は、クラス内で宣言する場所を間違えている
- メンバ関数より、非メンバかつ非friend関数を優先することで、カプセル化を促進し、テスト可用性を高めることができる

## ガイドライン５：拡張に備え設計する

- 開放・閉鎖原則（OCP）のとおり、拡張は容易であるべきで、理想的には単にコードを追加するだけで住むべきであり、他コンポーネントの既存コードを改造するなどはあるべきではない
- コードの追加が容易になるよう、基底クラス、テンプレート、関数オーバーロード、テンプレートの特殊化といった手法を検討する
- C++標準ライブラリは、拡張に備えた設計の大変良いお手本である

# 2. 抽象化の技
## ガイドライン６：抽象化から期待される動作に従う

- LSP（リスコフ置換原則）を守るためには、下記が常に守られることを保証しなければならない
  - 具象クラスでは事前条件を強めてはならない
  - 具象クラスでは事後条件を弱めてはならない
  - 具象クラスのメソッドの戻り型は、共変でなければならない
    - つまり、具象クラスをそのまま返せなければならない
  - 具象クラスのメソッドの引数の型は、反変でなければならない
    - つまり、基底クラスをそのまま入力にできなければならない
  - 基底クラスの不変条件は、具象クラスでも維持しなければならない

- ポインタが指す具象クラスの型をdynamic_castなどで判別し、それによって呼び出し側の制御を変えている場合、紛れもなくLSP違反であり、非常に良くない
  - 派生クラスの動作に新たな依存関係を発生させてしまうため

- 抽象化が期待する内容の明確化や、誤解の余地がない表現を明文化することも重要
  - 参考：[C++標準にあるイテレータコンセプトの説明文](https://en.cppreference.com/w/cpp/iterator)

## ガイドライン７：基底クラスとコンセプトの共通性を把握する

- 動的多態性（継承）だけでなく、静的多態性（テンプレート）もLSPの対象である
- 静的多態性を用いる場合も、コンセプト（or C++以前のテンプレート引数名）が期待する内容を明確化しなければならない

## ガイドライン８：オーバーロードセットの意味的要件を理解する

- フリー関数をオーバーロードすることでも、静的多態性を実現できる
- そのため、オーバーロードされるべき関数は、期待を明確化しなければならず、既存の名前や命名規則に従うことで期待する内容を予想しやすくしなければならない

## ガイドライン９：抽象化の所有権に注意する

- 正しいアーキテクチャでは、下位（アプリケーション）の実装詳細が、上位（共通コンポーネント）の抽象化に依存する
- DIP（依存関係逆転の原則）を使うことで、上位が下位を呼び出す場合でも、アーキテクチャ上位で抽象化することが可能になる
- 抽象化を所有（ヘッダの提供など）するのは、上位（共通コンポーネント）でなければならない

## ガイドライン１０：アーキテクチャの文書化を検討する

- アーキテクチャドキュメントは保守や現状確認などの意思疎通をする上で必要不可欠
- アーキテクチャの現状と期待される状態を比較、確認するにはツールを使用する

# 3. デザインパターンの目的
## ガイドライン１１：デザインパターンの目的を把握する

- デザインパターンの名前を通して、開発者同士が考えている設計・目的のコミュニケーションコストを下げる
- デザインパターンは何らかの抽象化を用いて依存関係を軽減する
  - Strategyパターンを使って、Strategy使用者を具象Strategyの実装詳細から分離する
  - Factoryパターンを使って、特定の生成処理を分離する
- 実装パターンとは異なり、特定の実装に限定されない
  - 抽象化の実際の方法は、基底クラスに限らず、テンプレートや関数オーバーロード、なんなら関数ポインタでもよい

## ガイドライン１２：デザインパターンを誤解してはいけない

- デザインパターンは最終目的ではない
- デザインパターンは実装詳細ではない
- デザインパターンで用いる抽象化を実際実現する方法は、継承などの動的多態性でもテンプレート引数などの静的多態性でも状況に適したものを使えば良い

## ガイドライン１３：デザインパターンはどこにもある

- C++17から導入されたPolimorphic Allocatorでは、下記のデザインパターンが使われている
  - Template Methodパターン：`std::pmr::memory_resource`で派生クラス用に`do_allocate`, `do_deallocate`といったインタフェースが用意されている
  - Decoratorパターン：`std::pmr::memory_resource`のコンストラクタにそれ自身を渡すことで、複数のアロケータを階層化できる
  - Adapterパターン：`std::pmr::vector`という型エイリアスで、従来型の静的インターフェースと新しい動的アローケータインターフェースをつなぐ
  - Strategyパターン：`std::pmr`により、外部から`std::vector`などのメモリ割当をカスタマイズできる

- 抽象化、分離、柔軟性と拡張性の向上、どれもデザインパターンをもとにしていることが多い

- 32バイト以下の短い文字列は、SSO (Small String Optimization)いにょってスタック上に文字列を配置するのが一般的な`std::string`の実装である。

## ガイドライン１４：デザインパターン名を用い目的を伝える

- 型の名前に使用したデザインパターンを含めることで、設計の目的を明確にし、コードの読解性を向上するべき

# 4. Visitorパターン
## ガイドライン１５：型または処理の追加に備え設計する

- 手続き型プログラミングで素朴に実装した場合、処理の追加は容易だが、型の追加大変
  - 型を判定するためのswitch文がそこかしこにある
- 動的多態性（継承）を素朴に使えば、型の追加を簡単にすることはできるが、処理の追加は大変になる
  - 追加された処理を実装しなければならない具象クラスがそこかしこにある

- 将来拡張の方向性として、主に型の追加を想定するなら動的多態性を、主に処理の追加を想定するなら手続き型・関数型を優先する
- 静的多態性の場合、型も処理も容易に拡張できる

## ガイドライン１６：処理セットを拡張するにはVisitorパターン

- Visitorパターンは、処理を抽象化したVisitorクラスを用意し、処理要求時にはそのインスタンスを渡すことで、処理の追加を一箇所に集約する
- 古典的Visitorパターンの短所
  - Visitorの処理がほとんど同じでも、`visit()`をすべての具象クラスに対して定義しなければならない
  - `visit()`の返り値を派生クラスでは変更できない
  - 型を追加するときには、Visitorクラスの具象クラスをすべて変更しなければならない
  - 基底クラスに仮想関数`accept()`を加えることが問題となることがある
  - `accept()`が派生クラスに継承されるため、適切なoverrideが漏れると、見つけにくい不具合になる
  - ダブルディスパッチ（一回の処理で仮想関数を２回（`accept()`と`visit()`）呼び出す）になるため、性能面で不利
  - classが細分化されることで、メモリフラグメンテーションのリスクが増え、キャッシュ・最適化されづらくなる
  - classが細分化されることで、見通しが悪くなる

## ガイドライン１７：Visitorパターンの実装には`std::variant`を検討する

- C++17で導入された、`std::variant`を使うことで、古典的Visitorパターンの短所の多くを解決できる
  - 継承や仮想関数がなくなり、それに伴う制約・パフォーマンスの懸念・複雑性を回避できる
  - 暗黙的型変換を使って、`operator()`の処理をまとめて定義できる
- 一方で課題もあるため、それも踏まえて選択する必要がある
  - 型の追加時には、`std::variant`のテンプレート引数の追加と利用箇所の再コンパイル、`operator()`の実装追加が必要
    - 仮に実装追加を忘れた場合、わかりやすいエラーではないが、コンパイルエラーで気付ける
  - サイズが大きく異なる型を`std::variant`に持たせると、メモリを無駄遣いしてしまう
    - 処理速度とのトレードオフになるが、ProxyパターンやBrdigeパターンで回避する選択肢もある
  - `std::variant`は実体を持つため、型の内部情報を利用者に公開し、利用者は内部状態に対する依存を持つことになる
    - すなわち、内部状態変更時に再コンパイルが必要になる
    - 処理速度とのトレードオフになるが、ProxyパターンやBrdigeパターンで回避する選択肢もある

## ガイドライン１８：Acyclic Visitorの性能を把握する

- Acyclic Visitorを使えば、型の拡張にも処理の拡張にも開かれた設計にできる
- ただし、クロスキャストが深刻な性能上のオーバーヘッドを生むことを十分に留意する必要がある

# 5. StrategyパターンとCommandパターン

## ガイドライン１９：処理方法を分離するにはStrategyパターン

- 継承が解となるなることはほとんどない
- VisitorパターンとStrategyパターンの違い
  - Visitorパターンのバリエーションポイントは処理の汎用的な追加。つまり、汎用的な処理の追加を容易にする。その結果、型の追加が容易ではなくなる。
  - Strategyパターンのバリエーションポイントは単一関数の実装詳細。つまり、単一関数の実装パターンの追加を容易にする。そのため、メソッドそのものを追加するためには依然として仮想関数の追加という干渉が必要。

  - Strategyパターンの短所
    - 処理の追加は容易になっていない
    - 早い段階でバリエーションポイントを特定できなければ、大掛かりなリファクタリングが必要。ただし、もちろん必要かどうかわからないのにStrategyパターンをつかうのはNG
    - Strategy一つに付き、一つの処理か小規模な関数グループしか扱えない。DIするクラスもその単位ごとに複数必要になる。
      - もし多数の実装詳細を切り出す場合は、External PolymorphismパターにゃType Erasureパターンを検討すべき

- Strategyパターンは静的多態性（クラステンプレート）でも実装可能。ポリシベースの設計と呼ぶ
  - メリット
    - 値渡しができるため、ポインタの間接参照が減り、性能向上が見込める
  - デメリット
    - インスタンスごとにstrategyを変更できない
    - 実装詳細をヘッダに記述し、公開しなければならない

## ガイドライン２０：

- 

## ガイドライン２１：
