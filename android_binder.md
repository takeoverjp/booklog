# links

- [詳説 Binder](https://github.com/karino2/InsideBinder/blob/master/README.md)

# 第１章 Binderとシステムサービス

- Binderはシステムプログラミングの用途だけを念頭に作られている
- 同一マシン内だけでしか使えない
  - シンプルなインターフェース
  - コンパクトな実装
  - 高パフォーマンスで省メモリ
- ドライバとしてカーネルにアクセスすること前提
  - 通信のレイヤでスレッドを認識できる
  - 相手のタスク構造体を直接操作できる
    - ファイルディスクリプタが遅れる

- IBinder経由でアクセスすることでサービスの実装とプロキシを区別する必要がない
- インターフェース名.Stub.asInterface()を呼び出すことで、IBinderの中身を意識することなくサービスとやり取りできるインターフェースを取得できる

# 第２章 Binderの本格的な入門

- Binderを詳細に理解する意義
  - Androidソースコードを読む際に全てを正確に理解できるようになる
  - Androidのシステムサービスのメソッド呼出を、カーネルのコンテキストスイッチのレベルで理解できる
  - 実際に世界中で使われている分散オブジェクトのシステムを学習できる
  - Androidの哲学を知る手がかりになる

- Binderを構成するレイヤ
  - 共通ネイティブインターフェースのレイヤ
  - AIDLのレイヤ
  - スレッドプールのレイヤ
  - binderドライバ

# 第３章 binderドライバを扱う３つのシステムコール - open, mmap, ioctl

- binderドライバはmmapで送受信用のバッファをkernelメモリに確保し、user空間にmapする。
- 送信プロセスと受信プロセスの双方がこのmmapをしておくことで、データ送信時（実行プロセスが送信プロセスの時）に、kernelは受信プロセスのバッファに対してデータを書き込むことができる。

# 第４章 binderドライバによるメッセージの送受信 - servicemanagerとサービス

- ハンドルが0番が予約されているservice managerが必ずいて、そいつがサービスハンドルの登録と検索APIを提供している

# 第5章 binderドライバの内側とオブジェクトの送信- flat_binder_object

- メソッド呼び出しを実現するため、`BC_TRANSACTION`(呼出)と`BC_REPLY`(応答)の2種類のioctlがあり、`BC_REPLY`を送るときには対応する`BC_TRANSACTION`を送ってきたスレッドに送信しなければならない。binderドライバはioctlごとに呼出スレッドを記憶しており、`BC_REPLY`時に暗黙的に応答を返すスレッドを適切に選択してくれる。
- binderはfd passing (送信プロセスであるfdが指すファイルオブジェクトと同一のファイルオブジェクトをさすfdを、受信プロセスのfdテーブルに登録した上でそのfdを送る) もサポートしている。

# 第6章 スレッドプールのレイヤ - BBinder と IPCThreadState

- `getService()`で`IBinder`を得られるが、これは同一プロセスの場合は`BBinder`(ただのポインタ)であり、別のプロセスの場合は`BpBinder`(プロキシ)になる
- Androidでは、サービスの実装をいじらずにプロセス構成やスレッド数といったリソースやシステム構成の設計を行うことができるように工夫されている

# 第７章 共通ネイティブインターフェースのレイヤ- IInterfaceとinterface_cast

- プロセスをまとめたい理由
  - 計算資源の節約
- プロセスをわけたい理由
  - スケジューリングポリシー設定が容易になる
  - キャッシュの最適化が可能
  - セキュリティの向上

- 引数の文字列により各インターフェースを保持しているかを問い合わせるケースは、下記のパターンで必要になることがよくある
  - 型の無い言語で動的に問い合わせる
  - インターフェースのバージョニング
  - 特定のインターフェースを実装しているオブジェクトにだけアスペクトを注入するようなコンテナライブラリの存在
