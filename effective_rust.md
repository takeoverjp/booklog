# Effective Rust

## Links

- [Effective Rust](https://www.oreilly.co.jp//books/9784814400942/)

## 1. 型

### 項目1：データ構造を表現するために型システムを用いよう

- Rustの型システムは、他の静的型付け言語に馴染みがある
- isizeとusizeはポインタサイズと一致する
- Rustでは整数型の変換は明示的に行う必要がある
- 配列、タプル、構造体などの集約型が用意されている
- enum型は相互に排他な値の集合を指定するために用いられる
- enumは個々のヴァリアントにデータを付加できる
- Option<T>とResult<T, E>は非常に一般的なenum型である
- match式で型安全性を確保する
- **型で無効な状態を表現できないようにする**ことが重要
- Rustの型システムを用いて設計の意図を明確に伝える

### 項目2：型システムを用いて共通の挙動を表現しよう

- `fn`型は`Copy`と`Eq`を実装し、`std::fmt::Pointer`も実装する
  - 例: `let op1 = op; let op2 = op; assert!(op1 == op2); println!("op = {:p}", op);` 出力例: `"op = 0x101e9aeb0"`

- 関数の名前だけでは`fn`型にならず、明示的な自動型変換が必要である
  - 例: `let op1 = sum; let op2 = sum;` はコンパイルエラーになる
  - エラーメッセージ: `error[E0369]: binary operation == cannot be applied to type fn(i32, i32) -> i32 {main::sum}`

- クロージャは関数定義のボディ部のように見えるコード片（ラムダ式）である
  - 式の一部にできるため、名前を付ける必要がない
  - 入力引数はバー（|）で囲って与える
  - 包含する環境の一部をキャプチャできる

- 例: `let amount_to_add = 3; let add_n = |y| { y + amount_to_add }; let z = add_n(5); assert_eq!(z, 8);`

- コンパイラがラムダ式で参照されている環境の部分を保持した特注の内部型を作成し、クロージャが作成されると、この一時的な型のインスタンスが作られ、関連する値が格納される

- クロージャを関数ポインタの代わりに使うことはできない
  - エラーメッセージ: `error[E0308]: mismatched types`

- Rustには3種類のFn*トレイトがある
  - `FnOnce`: 1度だけ呼び出せるクロージャ
  - `FnMut`: 繰り返し呼び出せるクロージャ（環境を可変借用）
  - `Fn`: 繰り返し呼び出せるクロージャ（環境を共有借用）

- 例: `pub fn modify_all<F>(data: &mut [u32], mut mutator: F) where F: FnMut(u32) -> u32 { for value in data { *value = mutator(*value); } }`

- トレイトは関数のシグネチャだけでなく、関数の意図を表現するための機構である
- トレイトを実装する型は、トレイトのすべての関数を実装しなければならない

- 例: `pub trait Sort { fn sort(&mut self); } pub trait StableSort: Sort {}`

- Rustの型システムにおけるトレイトの使い方
  - トレイト制約として用いる。ジェネリック型や関数の型をコンパイル時に制約する
  - トレイトオブジェクトとして用いる。格納や関数に渡す型を実行時に制約する

### 項目3：OptionとResultに対してはmatchを用いずに変換しよう

- match式を使わずに変換メソッドを使用する利点
  - よりコンパクトで定型的なコードになる
  - 意図がはっきりとわかるコードになる

- 値のみが重要で、値がない場合は無視していい場合、if letを用いると明確になる
- 失敗時にpanic!を行う場合、unwrapとexpectメソッドを使用する
- クエスチョンマーク演算子?を使用してエラーを伝搬する
- エラーマッピングを行う場合、map_errメソッドを使用する
- Optionへの参照を、参照のOptionに変換する場合、as_refメソッドを使用する
- Resultにはmust_use属性があり、無視した場合はコンパイラが警告する
- ![OptionとResultの変換](https://oreil.ly/effective_rust_transforms)

### 項目4：標準のError型を使おう

- Result<T, E>のEにくるさまざまなエラー型をどう扱うかがテーマである
- すべてのエラーが同じ型であればその型を返せばよいが、異なる型のエラーがある場合にはサブエラーの型を保持する方法を決める必要がある
- std::error::Errorトレイトを実装することで、エラー型を統一することができる
- Errorトレイトを実装するためには、DisplayトレイトとDebugトレイトを実装する必要がある
- Errorトレイトの唯一のメソッドはsource()であり、内部にネストされたエラーを開示するために用いる
- String型をラップするタプル構造体を作成し、Errorトレイトを実装することができる
- すべてのサブエラー型にFromトレイトを実装しておくと便利である
- enumを使うことで、それぞれのエラーに関するすべての型情報を維持しつつコンパクトにエラー処理を行うことができる
- トレイトオブジェクトを使うことで、サブエラー情報を維持しつつ、すべての可能性のあるサブエラー型を手で書き出す必要がなくなる
- anyhowクレートを利用することで、エラー処理を簡素化し、スタックトレースなどの機能を提供することができる
- アプリケーションのエラー処理においては、様々なエラーをどのようにユーザに見せるかを一貫したエラー処理で実現するために、anyhowの利用を検討することが推奨される。一方で、ライブラリでは、具体的で詳細なエラー情報を出力し、パブリックAPIがanyhowに依存しないようにするため、ネストしたエラーを用いるべきである

### 項目5：型変換を理解しよう

- Rustの型変換は3つに大別される
  - 手動: ユーザがFromトレイトとIntoトレイトを実装して定義した型変換
  - 半自動: asキーワードを用いた明示的なキャスト
  - 自動: 暗黙のうちに行われる新しい型への自動型変換（coercion）

- 手動型変換
  - From<T>: 型Tのアイテムから作成でき、変換は常に成功する
  - TryFrom<T>: 型Tのアイテムから作成できるが、変換は失敗する可能性がある
  - Into<T>: 型Tのアイテムへ変換でき、変換は常に成功する
  - TryInto<T>: 型Tのアイテムへ変換できるが、変換は失敗する可能性がある

- ユーザ定義型の対応方針
  - 変換が失敗する可能性がある場合にはTry...トレイトを実装する
  - Fromトレイトを実装すると自動的にIntoトレイトも提供されるので、Fromを実装する
  - トレイト制約にはIntoを使う

- キャスト
  - asキーワードを用いた明示的なキャスト
  - 一般的な整数型間の変換が可能
  - from/intoで書くとコンパイラに拒絶される変換もある
  - 一貫性と安全性のためにfrom/intoによる変換を推奨する

- 自動型変換
  - ポインタと参照型に関する暗黙の変換が多い
  - DerefもしくはDerefMutトレイトを実装している場合に自動型変換が行われる
  - 具象型からトレイトオブジェクトへの変換も自動型変換の一つである

### 項目 6:newtype パターンを活用しよう

- newtypeパターンは、既存の型一つだけをフィールドとしてもつタプル構造体
  - 型エイリアスと違って、用途ごとに異なる型を定義できるので、誤った値を渡すことを防げる
    - 単位のセマンティクスを型に追加したり、真偽値の曖昧さを解消するためにも使える
  - #[repr(transparent)]属性により、メモリ効率、バイナリ互換性を損なわないことを保証できる
  - トレイトの孤児ルールを回避するためにも使える
- newtypeに対する全ての操作を、内部の型に転送しなければならない

### 項目7：複雑な型にはビルダを使おう

- 複雑なデータ構造にはビルダ型を用意する
  - Rustはstructを新たに作成する際にすべてのフィールドを指定することを要求する
  - 例えば、Optionとなっているフィールドはすべて明示的にNoneとしなければならない
  - ビルダパターンを実装することで、複雑なデータ構造の構築を人間工学的に改善する
  - ビルダ型には、構築に必要な情報を保持する構造体を別に持ち、構築するのに必要なフィールドを埋めるためのヘルパメソッドを用意する
- Defaultトレイト
  - Defaultトレイトを実装しておけば定型的なコードはずっと短くできる
  - Defaultを実装していないフィールドがあると、deriveできない
- selfを消費するビルダ
  - ヘルパメソッドはselfを消費するが、新しいSelfを返すので、構築メソッドを連鎖させることができる
  - 最後のメソッド(`build()`)を実行するとビルダが消費され、ビルド対象のデータ構造が返される
  - 構築プロセスを複数のステージに分割できないという問題があるが、同じ変数にビルダを書き戻すことで解決できる
- selfを消費しないビルダの書き方として、メソッドで&mut selfを受け取って&mut Selfを返す方法がある
  - 複数のインスタンスを作れるようにすることもできる
  - その場合、`build()`が呼び出されるたびに新しいインスタンスを作らなければならない
- 定型的なコードはマクロを使えばさらに減らすことができるかもしれないが、その場合は既存のクレート（具体的にはderive_builderクレート）で必要なことができないか調べてみる

### 項目8：参照型とポインタ型に慣れよう

- 参照とポインタの基本
  - 参照は内部的にはポインタとして実装される
  - CPUはポインタに対して有効なメモリ範囲とアラインメントの制約を課している
  - 高レベル言語では型システムによってポインタにより多くの情報をエンコードする

- Rustの参照の特徴
  - &Tは最も一般的な参照型で、読み出しのみ可能
  - &mut Tは可変参照で、値の変更も可能
  - 参照は常に有効で正しくアラインされた型Tのオブジェクトを指す必要がある
  - 生存期間と借用ルールの制約を満たす必要がある

- ポインタトレイト
  - Derefトレイトは参照解決の自動型変換を提供する。自動方変換できるように変換先は一つ。
  - AsRef/AsMutトレイトは明示的な参照変換を提供する。変換先の型をジェネリック引数として受け取ることで、複数の変換先型をサポートできる。

- ファットポインタ型
  - スライス(&[T])は値の連続したコレクションの一部を指す16バイトの参照
  - トレイトオブジェクト(&dyn Trait)は具体的な型へのポインタとvtableへのポインタを持つ
    - vtableはトレイトメソッドの実装への関数ポインタを保持する

- その他のポインタ関連トレイト
  - Pointerトレイトはデバッグ用のフォーマット出力を提供する
  - Borrow/BorrowMutトレイトは参照型と値型の両方を受け付けられる柔軟な借用を提供する

### 項目9：明示的なループの代わりにイテレータ変換を使用することを検討しよう

- イテレータ変換の利点
  - 明示的なループよりも意図が明確になる
  - コードが短くなる
  - 効率的な場合がある（コンパイラが境界チェックをスキップできる）

- イテレータ変換式の3つの要素
  - イテレータのソース（Iteratorトレイトを実装した型のインスタンス）
  - イテレータ変換の連鎖
  - 最後の消費メソッド

- イテレータトレイトの基本
  - Iteratorトレイトは`next()`メソッドのみを必須とする
  - IntoIteratorトレイトにより、コレクションをイテレータに変換できる
  - `for`ループは内部的にIntoIteratorを使用する

- イテレータの種類
  - 消費するイテレータ（コレクションの所有権を取る）
  - 参照イテレータ（`iter()`で取得、要素への参照を返す）
  - 可変参照イテレータ（`iter_mut()`で取得、要素への可変参照を返す）

- 主なイテレータ変換メソッド
  - 繰り返し操作に影響するもの（`take`, `skip`, `step_by`, `chain`, `cycle`, `rev`）
  - アイテムの性質に関わるもの（`map`, `cloned`, `copied`, `enumerate`, `zip`）
  - フィルタリング（`filter`, `take_while`, `skip_while`）
  - フラット化（`flatten`）

- イテレータ消費メソッド
  - 汎用的な`for_each`
  - 集約操作（`sum`, `product`, `min`, `max`）
  - 汎用的な集約（`reduce`, `fold`）

- ターボフィッシュ記法の`collect::<Result<Vec<_>, _>>()?`を使うことで、Result値からコレクションを作ることができる

- コンパクトさと明確さの観点からイテレータ変換は明示的なループよりも優れている
- しかし、以下の場合は明示的なループを使う
  - ループボディが大きいもしくは多機能な場合
  - ループボディがエラーになる場合があり、周辺の関数の早期終了を引き起こす可能性がある場合
  - 性能が極めて重要で、測定して比較した結果、イテレータ変換がボトルネックになった場合

## 2. トレイト

### 項目10：標準トレイトに習熟しよう

- 標準トレイトの重要性
  - 型システムの重要な挙動を表現する
  - C++のコピーコンストラクタ・デストラクタ・比較演算子・代入演算子などに相当する機能を提供する
  - 自作の型に実装すべき
  - deriveマクロで自動実装が可能

- 主な標準トレイト
  - Clone: 明示的なコピーを提供する。リソースへのユニークなアクセスを表している場合や、コピーを妨げる理由(例：鍵)がある場合は実装すべきでない。
  - Copy: メモリ上のビットコピーが可能。ビットコピーが安全かつ高速な場合のみ実装する。型はコピーセマンティクスになるので最も注意が必要。
  - Default: デフォルト値を提供する。構造体の初期化を簡潔にする
  - PartialEq/Eq: 等価性の比較を提供する
  - PartialOrd/Ord: 順序付けを提供する。比較演算子の実装に使用する。deriveしたときにはフィールド定義順に比較する。
  - Hash: ハッシュ値の計算を提供する。ハッシュマップのキーとして使用する際に必要
  - Debug: プログラマ向けの表示を提供する
  - Display: ユーザー向けの表示を提供する

- 実装の判断基準
  - 型の性質に応じて適切なトレイトを選択する
  - deriveマクロで自動実装できない場合は手動実装を検討する
  - トレイト間の整合性を保つ
  - パフォーマンスへの影響を考慮する

### 項目11：RAIIパターンにはDropトレイトを実装しよう

- RAIIパターンの特徴
  - コンストラクタで資源へのアクセスを確保する
  - デストラクタで資源へのアクセスを解放する
  - 不変条件として、アイテムが存在する間のみ資源へのアクセスが可能である
  - コンパイラがスコープ終了時の資源解放を保証する

- RAIIパターンの利点
  - コードのメンテナンス性が向上する
  - 資源の確保と解放が自動的に行われる
  - エラー処理時も資源の解放が保証される

- Dropトレイトの実装
  - RAIIパターンを実現するための中心的な機能である
  - dropメソッドは&mut selfを受け取る
  - 明示的な呼び出しはできず、コンパイラが自動的に呼び出す
  - 解放処理に対するエラー処理が必要な場合は別途releaseメソッドを実装する必要がある（返り値がないため）

- 主な用途
  - OSの資源管理（ファイルディスクリプタなど）
  - 同期用の資源管理（ミューテックス、ロックなど）
  - 低レベルのメモリ管理（FFIなど）

### 項目12：ジェネリクスとトレイトオブジェクトのトレードオフを理解しよう

- ジェネリクスとトレイトオブジェクトの基本的な違い
  - ジェネリクス：コンパイル時に型ごとに単相化された関数を生成する
  - トレイトオブジェクト：実行時に動的ディスパッチを行うvtableを使用する

- ジェネリクスの特徴
  - コードサイズが大きくなる傾向がある
  - メソッド呼び出しが若干高速
  - コンパイル時間が長くなる
  - 複数のトレイト制約を組み合わせやすい

- トレイトオブジェクトの特徴
  - コードサイズを抑えられる
  - vtableによる間接参照が必要
  - 複数のトレイトの組み合わせが困難
  - オブジェクト安全性の制約がある
    - ジェネリックメソッドを含めない
    - Self型の使用に制限がある

- トレイトオブジェクトが有効なケース
  - コードサイズやコンパイル時間が問題になる場合
  - 異なる型のオブジェクトを1つのコレクションで扱う場合
  - 実行時に動的にコードをロードする場合

- 選択の指針
  - パフォーマンスが重要な場合は実測して判断する
  - 複数のトレイト制約が必要な場合はジェネリクスを選ぶ
  - 型の異種混合が必要な場合はトレイトオブジェクトを選ぶ

### 項目13：デフォルト実装を用いて、実装しなければならないトレイトメソッドを最小限にしよう

- トレイトの2種類の利用者
  - トレイトを「実装する」プログラマ
  - トレイトを「使用する」使用者

- トレイト設計における対立関係
  - 実装者のために最小限のメソッドにしたい
  - 使用者のために多様なメソッドを提供したい
  - デフォルト実装によってこの対立を解決できる

- デフォルト実装の特徴
  - 基本的なメソッドを使って高度な機能を構築できる
  - 必要に応じて実装者がオーバーライド可能である
  - トレイト制約と組み合わせて使用できる

- 標準ライブラリでの活用例
  - ExactSizeIteratorのis_empty()メソッド
  - Iteratorトレイト（next()のみ必須で50以上のデフォルトメソッドを提供）
  - cloned()メソッドでのトレイト制約との組み合わせ

- デフォルト実装のメリット
  - 実装者は最小限のメソッドのみを実装すればよい
  - 使用者は豊富な機能を利用できる
  - 後方互換性を保ちながらメソッドを追加できる

## 3. さまざまなコンセプト

### 項目14：生存期間を理解しよう

- 生存期間の基本概念
  - すべての参照には生存期間が関連付けられている
  - 出力の生存期間は入力の生存期間に包含される必要がある
  - 生存期間は参照の有効範囲を示す
  - プログラマが生存期間についてできることは、名前をつけて、複数の生存期間が同じであることを示すことだけ

- 生存期間省略ルール
  - 1入力1出力の場合：出力は入力と同じ生存期間を持つ
  - 複数入力0出力の場合：入力はそれぞれ異なる生存期間を持つ
  - &selfを含む場合：出力は&selfと同じ生存期間を持つ

- 'static生存期間の特徴
  - プログラム全体で有効な生存期間を示す
  - staticなグローバル変数への参照に使用される
  - Box::leakによってヒープ上の値に付与できる

- ヒープ上の値の生存期間
  - 所有者の生存期間に紐づく
  - スタック上の変数かstaticで所有の連鎖が終わる
  - 所有者がドロップされると値もドロップされる

- データ構造と生存期間
  - 参照を含む構造体には生存期間パラメータが必要
  - 生存期間パラメータは伝染する
  - 可能な限り所有するデータ構造を使用すべき
  - 無名生存期間'_で生存期間の存在を明示できる

- Rust はさまざまな状況で、アイテムをスタック上のある場所から別の場所に移すこともある
し、スタックからヒープへ、ヒープからスタックへと移すこともある。

### 項目15：借用チェッカを理解しよう

- 借用チェッカの基本概念
  - 参照は「借用」されるため永続的に保持できず、スコープは必ず参照先のアイテムの生存期間よりも小さくなければならない
  - 複数の不変参照または単一の可変参照のみを許可する
  - ノンレキシカル生存期間により、参照の生存期間は最後の使用時点で終了する

- 借用チェッカのエラー対処法
  - ブロックスコープによる生存期間の縮小
  - 名前付きローカル変数による生存期間の拡大
  - 一時的なローカル変数追加によるコードの特定

- スマートポインタの活用
  - 相互接続されたデータ構造の実装に有効
  - Rc/Arc、RefCell/Mutex、Weak等の使い分け
  - Rc/RefCellにより、実行時チェックのコストと引き換えに柔軟性を得ることができる

- 自己参照データ構造の課題
  - 所有データと参照の混在による実装の困難さ
  - データ移動時の参照の無効化問題
  - Pin型やライブラリの活用による対処

- 実装上の注意点
  - スマートポインタの適切な選択
  - 実行時パニックの可能性への考慮
  - 可能な限り自己参照構造を避ける
  - 既存のライブラリソリューションの活用

### 項目16：unsafeコードを書かないようにしよう

- unsafeコードの基本概念
  - Rustの実行時オーバーヘッドのないメモリ安全性が特徴である
  - unsafeはRustの制限を緩和するスーパーセットである
  - 生ポインタの使用が可能になるが、安全性の保証は開発者の責任となる

- unsafeコードの使用判断
  - 低レイヤのライブラリコードやFFIで必要となる場合がある
  - 多くの場合、標準ライブラリや既存のクレートで対応可能である
  - 標準ライブラリ内でも多数のunsafeコードが使用されている

- 標準ライブラリのunsafe実装例
  - スマートポインタ型（Rc、RefCell、Arc）
  - 同期プリミティブ（Mutex、RwLock）
  - Pin、Cow、std::memなどの高度な機能

- 代替手段の検討
  - 標準ライブラリの機能を優先的に使用する
  - crates.ioのエコシステムから適切なクレートを探す
  - once_cell、rand、byteorder、cxxなどの実績あるクレートを活用する

- unsafeコード作成時の注意点
  - 安全性に関するドキュメントを詳細に記述する
  - unsafeブロックの範囲を最小限に抑える
  - テストとツール (Miri等) による検証を徹底する
  - マルチスレッド環境での動作を慎重に検討する

### 項目 17：状態共有並列実行には気を付けよう

- Rustによりデータ競合は回避できるが、デッドロックは回避できない
- Sendトレイトはスレッド間でデータをやり取りできることを、Syncトレイトは複数のスレッドから安全にアクセスできることを表す
- メモリを共有して通信してはならない。通信してメモリを共有しよう
- 相互に整合していなければならないデータは、一つのロックで保護する
- ロックを保持したままクロージャを起動しない、MutexGuardを呼び出し元に返さない
- CIにデッドロック検出ツールを加える。no_deadlocks, Thread Sanitizer, parking_lot::deadlocksなど
- エンジニアがミスを侵さないことに依存した戦略は長期的には失敗する

### 項目18：パニックを避けよう

- パニックの基本概念
  - プログラムの回復不能なバグに対処するための機構である
  - デフォルトではパニック発生スレッドを停止する
  - catch_unwindによる例外処理のシミュレートは推奨されない

- パニック使用の問題点
  - パニックの巻き戻りが保証されない
  - プロジェクト設定やプラットフォームに依存する
  - データ構造の整合性が失われる可能性がある
  - FFI境界との相性が悪い

- 推奨されるエラー処理方法
  - ライブラリコードではResultを返す
  - エラー処理を呼び出し側に委ねる
  - ?演算子を活用する
  - mainでのみパニックを許容する

- パニックが許容される場合
  - エラーが非常に稀な場合
  - 内部データの破損時
  - 無効な入力が通常の範囲を超えている場合
  - 失敗しないバージョンと失敗する可能性のあるバージョンをペアで提供する

- パニックを避けるための注意点
  - unwrap()、expect()、unreachable!()などの関数を避ける
  - 配列の範囲外アクセスやゼロ除算に注意する
  - CIでパニックの可能性があるコードを検出する
  - no_panicクレートなどのツールを活用する

### 項目 19：リフレクションを避けよう

- Rustはフルのリフレクションをサポートしない
- RTTIに類する機能としてstd::anyがあるが、ジェネリクスで実装されており、コンパイル時の情報のみをつかうことができる
- リフレクションが必要となったとき、Rustでは制御対象クラスがトレイトを実装するようにデザインすべき

### 項目 20:過剰な最適化の誘惑を退けよう

- Rustでは一般にコピーとメモリ確保を明示的な過程にしているため、プログラマhs過剰にコピーを避けようとしてしまう
- 性能のための最適化は、その性能インパクトが課題として表面化してから行う
- スマートポインタを使うことで、簡潔で維持管理しやすく、使いやすい設計にできる場合もあることを忘れない

## 4. 依存ライブラリ

### 項目 21:セマンティックバージョン(SemVer)を理解しよう

- クレート作者
  - git tagとバージョンを一致させる
  - 後方互換性については、The Cargo Bookを参照する
  - 可能な選択肢の集合の変更は破壊的な変更
  - パブリックにインスタンス生成可能な構造体にメンバーを追加するのは破壊的変更
  - ライセンスの変更は破壊的
  - デフォルトフィーチャーの変更は破壊的
- クレート利用者
  - バージョンを明記する
  - cargo update等で適切に更新する

### 項目 22:可視範囲を最小化しよう

- のちの選択の幅を狭めないため
  - 複数のユーザーがいて長期間使われるライブラリが気にすべきことだが、想定以上に広く長く使われることは稀によくある

### 項目 23：ワイルドカードインポートを避けよう

- 自分で制御できないクレートからのワイルドカードインポートは避けるべき
- 例外
  - テストコードからテスト対象コードをインポートするとき
  - コード分割のためにモジュール化をつかつとき
  - preludeモジュールをワイルドカードインポートして再エクスポートする設計のクレートを使うとき

### 項目24： APIに型が登場する依存ライブラリは再エクスポートしよう

- まず、APIに依存ライブラリの型を登場させるときは、よく考える
- それでも登場させることが妥当な場合は、クレート利用者がクレートの依存バージョンを指定できるように、クレート利用者にとって必要となる依存ライブラリのAPIをさいえくすぽーとしておくべきである

### 項目 25：依存グラフを管理しよう

- crates.ioのク
レート名は単一のフラットな名前空間である
- Cargoは同じクレートのSemVer非互換な複数のバージョンを1つのビルドに含めることを許す
  - ただし、FFIによりC/C++にアクセスしている場合はその限りではない
- 依存ライブラリを指定する際にはSemVer互換なバージョンを許すようにする

### 項目 26：忍び寄るフィーチャに注意しよう

- フィーチャ名の空間は依存クレートの名前空間と重なっているので、フィーチャ名は慎重に選ばなければならない
- フィーチャは複数を同時に独立して有効にできなければならない
- フィーチャで、パブリックな構造体のフィールドやトレイトメソッドを制限しないしてはならない

## 5. ツール

### 項目 27：パブリックインターフェイスのドキュメントを書こう

- 便利な[`SomeThing`]構文を用いて識別子にクロスリファレンスを書く。SomeThingがスコープ内にあればそれに対するハイパーリンクがドキュメントに付与される。

### 項目 28：分別をもってマクロを使おう

- マクロは関数やジェネリクスでは抽象化できないトークンに対する抽象化ができる
- マクロ以外の手段で実現できない定型処理を整合させる必要があるなら、マクロを使う
- その場合、なるべく参照を挿入するようなマクロを避け、マクロの中に閉じない制御フローをマクロで使うのは避けるべきである

### 項目29：Clippyに耳を傾けよう

- [Clippyのlint警告のリスト](https://oreil.ly/Nt5zE) を読もう

### 項目 30：ユニットテスト以上のものを書こう

cargo/rustでは以下のテストをサポートしている

- ユニットテスト
  - ホワイトボックステスト。ソースコードと同じ場所におかれる
- 結合テスト
  - APIに対するテスト。testsディレクトリにおかれる。
- docket
  - ドキュメントに書かれたコードのテスト
- サンプルコード
  - examplesディレクトリにおかれる。
- ベンチマーク
- ファズテスト

### 項目31：ツールのエコシステムを活用しよう

- [rust playground](https://play.rust-lang.org)
- miri: unsafeコードのチェック
- dependabot: 依存ライブラリの更新管理
- cargo-semver-checks: セマンティックバージョンが正しく付与できているか
- cargo-expand: マクロで変なことが起きた時の解析
- [Godbolt compiler explorer](https://rust.godbolt.org): 機械語の確認

## 6. 標準Rustの向こうへ
