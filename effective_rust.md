# Effective Rust

## Links

- [Effective Rust](https://www.oreilly.co.jp//books/9784814400942/)

## 1. 型

### 項目1：データ構造を表現するために型システムを用いよう

- Rustの型システムは、他の静的型付け言語に馴染みがある
- isizeとusizeはポインタサイズと一致する
- Rustでは整数型の変換は明示的に行う必要がある
- 配列、タプル、構造体などの集約型が用意されている
- enum型は相互に排他な値の集合を指定するために用いられる
- enumは個々のヴァリアントにデータを付加できる
- Option<T>とResult<T, E>は非常に一般的なenum型である
- match式で型安全性を確保する
- **型で無効な状態を表現できないようにする**ことが重要
- Rustの型システムを用いて設計の意図を明確に伝える

### 項目2：型システムを用いて共通の挙動を表現しよう

- `fn`型は`Copy`と`Eq`を実装し、`std::fmt::Pointer`も実装する
  - 例: `let op1 = op; let op2 = op; assert!(op1 == op2); println!("op = {:p}", op);` 出力例: `"op = 0x101e9aeb0"`

- 関数の名前だけでは`fn`型にならず、明示的な自動型変換が必要である
  - 例: `let op1 = sum; let op2 = sum;` はコンパイルエラーになる
  - エラーメッセージ: `error[E0369]: binary operation == cannot be applied to type fn(i32, i32) -> i32 {main::sum}`

- クロージャは関数定義のボディ部のように見えるコード片（ラムダ式）である
  - 式の一部にできるため、名前を付ける必要がない
  - 入力引数はバー（|）で囲って与える
  - 包含する環境の一部をキャプチャできる

- 例: `let amount_to_add = 3; let add_n = |y| { y + amount_to_add }; let z = add_n(5); assert_eq!(z, 8);`

- コンパイラがラムダ式で参照されている環境の部分を保持した特注の内部型を作成し、クロージャが作成されると、この一時的な型のインスタンスが作られ、関連する値が格納される

- クロージャを関数ポインタの代わりに使うことはできない
  - エラーメッセージ: `error[E0308]: mismatched types`

- Rustには3種類のFn*トレイトがある
  - `FnOnce`: 1度だけ呼び出せるクロージャ
  - `FnMut`: 繰り返し呼び出せるクロージャ（環境を可変借用）
  - `Fn`: 繰り返し呼び出せるクロージャ（環境を共有借用）

- 例: `pub fn modify_all<F>(data: &mut [u32], mut mutator: F) where F: FnMut(u32) -> u32 { for value in data { *value = mutator(*value); } }`

- トレイトは関数のシグネチャだけでなく、関数の意図を表現するための機構である
- トレイトを実装する型は、トレイトのすべての関数を実装しなければならない

- 例: `pub trait Sort { fn sort(&mut self); } pub trait StableSort: Sort {}`

- Rustの型システムにおけるトレイトの使い方
  - トレイト制約として用いる。ジェネリック型や関数の型をコンパイル時に制約する
  - トレイトオブジェクトとして用いる。格納や関数に渡す型を実行時に制約する

### 項目3：OptionとResultに対してはmatchを用いずに変換しよう

- match式を使わずに変換メソッドを使用する利点
  - よりコンパクトで定型的なコードになる
  - 意図がはっきりとわかるコードになる

- 値のみが重要で、値がない場合は無視していい場合、if letを用いると明確になる
- 失敗時にpanic!を行う場合、unwrapとexpectメソッドを使用する
- クエスチョンマーク演算子?を使用してエラーを伝搬する
- エラーマッピングを行う場合、map_errメソッドを使用する
- Optionへの参照を、参照のOptionに変換する場合、as_refメソッドを使用する
- Resultにはmust_use属性があり、無視した場合はコンパイラが警告する
- ![OptionとResultの変換](https://oreil.ly/effective_rust_transforms)

### 項目4：標準のError型を使おう

- Result<T, E>のEにくるさまざまなエラー型をどう扱うかがテーマである
- すべてのエラーが同じ型であればその型を返せばよいが、異なる型のエラーがある場合にはサブエラーの型を保持する方法を決める必要がある
- std::error::Errorトレイトを実装することで、エラー型を統一することができる
- Errorトレイトを実装するためには、DisplayトレイトとDebugトレイトを実装する必要がある
- Errorトレイトの唯一のメソッドはsource()であり、内部にネストされたエラーを開示するために用いる
- String型をラップするタプル構造体を作成し、Errorトレイトを実装することができる
- すべてのサブエラー型にFromトレイトを実装しておくと便利である
- enumを使うことで、それぞれのエラーに関するすべての型情報を維持しつつコンパクトにエラー処理を行うことができる
- トレイトオブジェクトを使うことで、サブエラー情報を維持しつつ、すべての可能性のあるサブエラー型を手で書き出す必要がなくなる
- anyhowクレートを利用することで、エラー処理を簡素化し、スタックトレースなどの機能を提供することができる
- アプリケーションのエラー処理においては、様々なエラーをどのようにユーザに見せるかを一貫したエラー処理で実現するために、anyhowの利用を検討することが推奨される。一方で、ライブラリでは、具体的で詳細なエラー情報を出力し、パブリックAPIがanyhowに依存しないようにするため、ネストしたエラーを用いるべきである

### 項目5：型変換を理解しよう

- Rustの型変換は3つに大別される
  - 手動: ユーザがFromトレイトとIntoトレイトを実装して定義した型変換
  - 半自動: asキーワードを用いた明示的なキャスト
  - 自動: 暗黙のうちに行われる新しい型への自動型変換（coercion）

- 手動型変換
  - From<T>: 型Tのアイテムから作成でき、変換は常に成功する
  - TryFrom<T>: 型Tのアイテムから作成できるが、変換は失敗する可能性がある
  - Into<T>: 型Tのアイテムへ変換でき、変換は常に成功する
  - TryInto<T>: 型Tのアイテムへ変換できるが、変換は失敗する可能性がある

- ユーザ定義型の対応方針
  - 変換が失敗する可能性がある場合にはTry...トレイトを実装する
  - Fromトレイトを実装すると自動的にIntoトレイトも提供されるので、Fromを実装する
  - トレイト制約にはIntoを使う

- キャスト
  - asキーワードを用いた明示的なキャスト
  - 一般的な整数型間の変換が可能
  - from/intoで書くとコンパイラに拒絶される変換もある
  - 一貫性と安全性のためにfrom/intoによる変換を推奨する

- 自動型変換
  - ポインタと参照型に関する暗黙の変換が多い
  - DerefもしくはDerefMutトレイトを実装している場合に自動型変換が行われる
  - 具象型からトレイトオブジェクトへの変換も自動型変換の一つである

### 項目 6:newtype パターンを活用しよう

- newtypeパターンは、既存の型一つだけをフィールドとしてもつタプル構造体
  - 型エイリアスと違って、用途ごとに異なる型を定義できるので、誤った値を渡すことを防げる
    - 単位のセマンティクスを型に追加したり、真偽値の曖昧さを解消するためにも使える
  - #[repr(transparent)]属性により、メモリ効率、バイナリ互換性を損なわないことを保証できる
  - トレイトの孤児ルールを回避するためにも使える
- newtypeに対する全ての操作を、内部の型に転送しなければならない

### 項目7：複雑な型にはビルダを使おう

- 複雑なデータ構造にはビルダ型を用意する
  - Rustはstructを新たに作成する際にすべてのフィールドを指定することを要求する
  - 例えば、Optionとなっているフィールドはすべて明示的にNoneとしなければならない
  - ビルダパターンを実装することで、複雑なデータ構造の構築を人間工学的に改善する
  - ビルダ型には、構築に必要な情報を保持する構造体を別に持ち、構築するのに必要なフィールドを埋めるためのヘルパメソッドを用意する
- Defaultトレイト
  - Defaultトレイトを実装しておけば定型的なコードはずっと短くできる
  - Defaultを実装していないフィールドがあると、deriveできない
- selfを消費するビルダ
  - ヘルパメソッドはselfを消費するが、新しいSelfを返すので、構築メソッドを連鎖させることができる
  - 最後のメソッド(`build()`)を実行するとビルダが消費され、ビルド対象のデータ構造が返される
  - 構築プロセスを複数のステージに分割できないという問題があるが、同じ変数にビルダを書き戻すことで解決できる
- selfを消費しないビルダの書き方として、メソッドで&mut selfを受け取って&mut Selfを返す方法がある
  - 複数のインスタンスを作れるようにすることもできる
  - その場合、`build()`が呼び出されるたびに新しいインスタンスを作らなければならない
- 定型的なコードはマクロを使えばさらに減らすことができるかもしれないが、その場合は既存のクレート（具体的にはderive_builderクレート）で必要なことができないか調べてみる

### 項目8：参照型とポインタ型に慣れよう

- 参照とポインタの基本
  - 参照は内部的にはポインタとして実装される
  - CPUはポインタに対して有効なメモリ範囲とアラインメントの制約を課している
  - 高レベル言語では型システムによってポインタにより多くの情報をエンコードする

- Rustの参照の特徴
  - &Tは最も一般的な参照型で、読み出しのみ可能
  - &mut Tは可変参照で、値の変更も可能
  - 参照は常に有効で正しくアラインされた型Tのオブジェクトを指す必要がある
  - 生存期間と借用ルールの制約を満たす必要がある

- ポインタトレイト
  - Derefトレイトは参照解決の自動型変換を提供する。自動方変換できるように変換先は一つ。
  - AsRef/AsMutトレイトは明示的な参照変換を提供する。変換先の型をジェネリック引数として受け取ることで、複数の変換先型をサポートできる。

- ファットポインタ型
  - スライス(&[T])は値の連続したコレクションの一部を指す16バイトの参照
  - トレイトオブジェクト(&dyn Trait)は具体的な型へのポインタとvtableへのポインタを持つ
    - vtableはトレイトメソッドの実装への関数ポインタを保持する

- その他のポインタ関連トレイト
  - Pointerトレイトはデバッグ用のフォーマット出力を提供する
  - Borrow/BorrowMutトレイトは参照型と値型の両方を受け付けられる柔軟な借用を提供する

## 2. トレイト

## 3. さまざまなコンセプト

## 4. 依存ライブラリ

## 5. ツール

## 6. 標準Rustの向こうへ
