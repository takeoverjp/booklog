# Effective Rust

## Links

- [Effective Rust](https://www.oreilly.co.jp//books/9784814400942/)

## 1. 型

### 項目1：データ構造を表現するために型システムを用いよう

- Rustの型システムは、他の静的型付け言語に馴染みがある
- isizeとusizeはポインタサイズと一致する
- Rustでは整数型の変換は明示的に行う必要がある
- 配列、タプル、構造体などの集約型が用意されている
- enum型は相互に排他な値の集合を指定するために用いられる
- enumは個々のヴァリアントにデータを付加できる
- Option<T>とResult<T, E>は非常に一般的なenum型である
- match式で型安全性を確保する
- **型で無効な状態を表現できないようにする**ことが重要
- Rustの型システムを用いて設計の意図を明確に伝える

### 項目2：型システムを用いて共通の挙動を表現しよう

- `fn`型は`Copy`と`Eq`を実装し、`std::fmt::Pointer`も実装する
  - 例: `let op1 = op; let op2 = op; assert!(op1 == op2); println!("op = {:p}", op);` 出力例: `"op = 0x101e9aeb0"`

- 関数の名前だけでは`fn`型にならず、明示的な自動型変換が必要である
  - 例: `let op1 = sum; let op2 = sum;` はコンパイルエラーになる
  - エラーメッセージ: `error[E0369]: binary operation == cannot be applied to type fn(i32, i32) -> i32 {main::sum}`

- クロージャは関数定義のボディ部のように見えるコード片（ラムダ式）である
  - 式の一部にできるため、名前を付ける必要がない
  - 入力引数はバー（|）で囲って与える
  - 包含する環境の一部をキャプチャできる

- 例: `let amount_to_add = 3; let add_n = |y| { y + amount_to_add }; let z = add_n(5); assert_eq!(z, 8);`

- コンパイラがラムダ式で参照されている環境の部分を保持した特注の内部型を作成し、クロージャが作成されると、この一時的な型のインスタンスが作られ、関連する値が格納される

- クロージャを関数ポインタの代わりに使うことはできない
  - エラーメッセージ: `error[E0308]: mismatched types`

- Rustには3種類のFn*トレイトがある
  - `FnOnce`: 1度だけ呼び出せるクロージャ
  - `FnMut`: 繰り返し呼び出せるクロージャ（環境を可変借用）
  - `Fn`: 繰り返し呼び出せるクロージャ（環境を共有借用）

- 例: `pub fn modify_all<F>(data: &mut [u32], mut mutator: F) where F: FnMut(u32) -> u32 { for value in data { *value = mutator(*value); } }`

- トレイトは関数のシグネチャだけでなく、関数の意図を表現するための機構である
- トレイトを実装する型は、トレイトのすべての関数を実装しなければならない

- 例: `pub trait Sort { fn sort(&mut self); } pub trait StableSort: Sort {}`

- Rustの型システムにおけるトレイトの使い方
  - トレイト制約として用いる。ジェネリック型や関数の型をコンパイル時に制約する
  - トレイトオブジェクトとして用いる。格納や関数に渡す型を実行時に制約する

### 項目3：OptionとResultに対してはmatchを用いずに変換しよう

- match式を使わずに変換メソッドを使用する利点
  - よりコンパクトで定型的なコードになる
  - 意図がはっきりとわかるコードになる

- 値のみが重要で、値がない場合は無視していい場合、if letを用いると明確になる
- 失敗時にpanic!を行う場合、unwrapとexpectメソッドを使用する
- クエスチョンマーク演算子?を使用してエラーを伝搬する
- エラーマッピングを行う場合、map_errメソッドを使用する
- Optionへの参照を、参照のOptionに変換する場合、as_refメソッドを使用する
- Resultにはmust_use属性があり、無視した場合はコンパイラが警告する
- ![OptionとResultの変換](https://oreil.ly/effective_rust_transforms)

### 項目4：標準のError型を使おう

- Result<T, E>のEにくるさまざまなエラー型をどう扱うかがテーマである
- すべてのエラーが同じ型であればその型を返せばよいが、異なる型のエラーがある場合にはサブエラーの型を保持する方法を決める必要がある
- std::error::Errorトレイトを実装することで、エラー型を統一することができる
- Errorトレイトを実装するためには、DisplayトレイトとDebugトレイトを実装する必要がある
- Errorトレイトの唯一のメソッドはsource()であり、内部にネストされたエラーを開示するために用いる
- String型をラップするタプル構造体を作成し、Errorトレイトを実装することができる
- すべてのサブエラー型にFromトレイトを実装しておくと便利である
- enumを使うことで、それぞれのエラーに関するすべての型情報を維持しつつコンパクトにエラー処理を行うことができる
- トレイトオブジェクトを使うことで、サブエラー情報を維持しつつ、すべての可能性のあるサブエラー型を手で書き出す必要がなくなる
- anyhowクレートを利用することで、エラー処理を簡素化し、スタックトレースなどの機能を提供することができる
- アプリケーションのエラー処理においては、様々なエラーをどのようにユーザに見せるかを一貫したエラー処理で実現するために、anyhowの利用を検討することが推奨される。一方で、ライブラリでは、具体的で詳細なエラー情報を出力し、パブリックAPIがanyhowに依存しないようにするため、ネストしたエラーを用いるべきである

### 項目5：型変換を理解しよう

- Rustの型変換は3つに大別される
  - 手動: ユーザがFromトレイトとIntoトレイトを実装して定義した型変換
  - 半自動: asキーワードを用いた明示的なキャスト
  - 自動: 暗黙のうちに行われる新しい型への自動型変換（coercion）

- 手動型変換
  - From<T>: 型Tのアイテムから作成でき、変換は常に成功する
  - TryFrom<T>: 型Tのアイテムから作成できるが、変換は失敗する可能性がある
  - Into<T>: 型Tのアイテムへ変換でき、変換は常に成功する
  - TryInto<T>: 型Tのアイテムへ変換できるが、変換は失敗する可能性がある

- ユーザ定義型の対応方針
  - 変換が失敗する可能性がある場合にはTry...トレイトを実装する
  - Fromトレイトを実装すると自動的にIntoトレイトも提供されるので、Fromを実装する
  - トレイト制約にはIntoを使う

- キャスト
  - asキーワードを用いた明示的なキャスト
  - 一般的な整数型間の変換が可能
  - from/intoで書くとコンパイラに拒絶される変換もある
  - 一貫性と安全性のためにfrom/intoによる変換を推奨する

- 自動型変換
  - ポインタと参照型に関する暗黙の変換が多い
  - DerefもしくはDerefMutトレイトを実装している場合に自動型変換が行われる
  - 具象型からトレイトオブジェクトへの変換も自動型変換の一つである

### 項目 6:newtype パターンを活用しよう

- newtypeパターンは、既存の型一つだけをフィールドとしてもつタプル構造体
  - 型エイリアスと違って、用途ごとに異なる型を定義できるので、誤った値を渡すことを防げる
    - 単位のセマンティクスを型に追加したり、真偽値の曖昧さを解消するためにも使える
  - #[repr(transparent)]属性により、メモリ効率、バイナリ互換性を損なわないことを保証できる
  - トレイトの孤児ルールを回避するためにも使える
- newtypeに対する全ての操作を、内部の型に転送しなければならない

### 項目7：複雑な型にはビルダを使おう

- 複雑なデータ構造にはビルダ型を用意する
  - Rustはstructを新たに作成する際にすべてのフィールドを指定することを要求する
  - 例えば、Optionとなっているフィールドはすべて明示的にNoneとしなければならない
  - ビルダパターンを実装することで、複雑なデータ構造の構築を人間工学的に改善する
  - ビルダ型には、構築に必要な情報を保持する構造体を別に持ち、構築するのに必要なフィールドを埋めるためのヘルパメソッドを用意する
- Defaultトレイト
  - Defaultトレイトを実装しておけば定型的なコードはずっと短くできる
  - Defaultを実装していないフィールドがあると、deriveできない
- selfを消費するビルダ
  - ヘルパメソッドはselfを消費するが、新しいSelfを返すので、構築メソッドを連鎖させることができる
  - 最後のメソッド(`build()`)を実行するとビルダが消費され、ビルド対象のデータ構造が返される
  - 構築プロセスを複数のステージに分割できないという問題があるが、同じ変数にビルダを書き戻すことで解決できる
- selfを消費しないビルダの書き方として、メソッドで&mut selfを受け取って&mut Selfを返す方法がある
  - 複数のインスタンスを作れるようにすることもできる
  - その場合、`build()`が呼び出されるたびに新しいインスタンスを作らなければならない
- 定型的なコードはマクロを使えばさらに減らすことができるかもしれないが、その場合は既存のクレート（具体的にはderive_builderクレート）で必要なことができないか調べてみる

### 項目8：参照型とポインタ型に慣れよう

- 参照とポインタの基本
  - 参照は内部的にはポインタとして実装される
  - CPUはポインタに対して有効なメモリ範囲とアラインメントの制約を課している
  - 高レベル言語では型システムによってポインタにより多くの情報をエンコードする

- Rustの参照の特徴
  - &Tは最も一般的な参照型で、読み出しのみ可能
  - &mut Tは可変参照で、値の変更も可能
  - 参照は常に有効で正しくアラインされた型Tのオブジェクトを指す必要がある
  - 生存期間と借用ルールの制約を満たす必要がある

- ポインタトレイト
  - Derefトレイトは参照解決の自動型変換を提供する。自動方変換できるように変換先は一つ。
  - AsRef/AsMutトレイトは明示的な参照変換を提供する。変換先の型をジェネリック引数として受け取ることで、複数の変換先型をサポートできる。

- ファットポインタ型
  - スライス(&[T])は値の連続したコレクションの一部を指す16バイトの参照
  - トレイトオブジェクト(&dyn Trait)は具体的な型へのポインタとvtableへのポインタを持つ
    - vtableはトレイトメソッドの実装への関数ポインタを保持する

- その他のポインタ関連トレイト
  - Pointerトレイトはデバッグ用のフォーマット出力を提供する
  - Borrow/BorrowMutトレイトは参照型と値型の両方を受け付けられる柔軟な借用を提供する

### 項目9：明示的なループの代わりにイテレータ変換を使用することを検討しよう

- イテレータ変換の利点
  - 明示的なループよりも意図が明確になる
  - コードが短くなる
  - 効率的な場合がある（コンパイラが境界チェックをスキップできる）

- イテレータ変換式の3つの要素
  - イテレータのソース（Iteratorトレイトを実装した型のインスタンス）
  - イテレータ変換の連鎖
  - 最後の消費メソッド

- イテレータトレイトの基本
  - Iteratorトレイトは`next()`メソッドのみを必須とする
  - IntoIteratorトレイトにより、コレクションをイテレータに変換できる
  - `for`ループは内部的にIntoIteratorを使用する

- イテレータの種類
  - 消費するイテレータ（コレクションの所有権を取る）
  - 参照イテレータ（`iter()`で取得、要素への参照を返す）
  - 可変参照イテレータ（`iter_mut()`で取得、要素への可変参照を返す）

- 主なイテレータ変換メソッド
  - 繰り返し操作に影響するもの（`take`, `skip`, `step_by`, `chain`, `cycle`, `rev`）
  - アイテムの性質に関わるもの（`map`, `cloned`, `copied`, `enumerate`, `zip`）
  - フィルタリング（`filter`, `take_while`, `skip_while`）
  - フラット化（`flatten`）

- イテレータ消費メソッド
  - 汎用的な`for_each`
  - 集約操作（`sum`, `product`, `min`, `max`）
  - 汎用的な集約（`reduce`, `fold`）

- ターボフィッシュ記法の`collect::<Result<Vec<_>, _>>()?`を使うことで、Result値からコレクションを作ることができる

- コンパクトさと明確さの観点からイテレータ変換は明示的なループよりも優れている
- しかし、以下の場合は明示的なループを使う
  - ループボディが大きいもしくは多機能な場合
  - ループボディがエラーになる場合があり、周辺の関数の早期終了を引き起こす可能性がある場合
  - 性能が極めて重要で、測定して比較した結果、イテレータ変換がボトルネックになった場合

## 2. トレイト

### 項目10：標準トレイトに習熟しよう

- 標準トレイトの重要性
  - 型システムの重要な挙動を表現する
  - C++のコピーコンストラクタ・デストラクタ・比較演算子・代入演算子などに相当する機能を提供する
  - 自作の型に実装すべき
  - deriveマクロで自動実装が可能

- 主な標準トレイト
  - Clone: 明示的なコピーを提供する。リソースへのユニークなアクセスを表している場合や、コピーを妨げる理由(例：鍵)がある場合は実装すべきでない。
  - Copy: メモリ上のビットコピーが可能。ビットコピーが安全かつ高速な場合のみ実装する。型はコピーセマンティクスになるので最も注意が必要。
  - Default: デフォルト値を提供する。構造体の初期化を簡潔にする
  - PartialEq/Eq: 等価性の比較を提供する
  - PartialOrd/Ord: 順序付けを提供する。比較演算子の実装に使用する。deriveしたときにはフィールド定義順に比較する。
  - Hash: ハッシュ値の計算を提供する。ハッシュマップのキーとして使用する際に必要
  - Debug: プログラマ向けの表示を提供する
  - Display: ユーザー向けの表示を提供する

- 実装の判断基準
  - 型の性質に応じて適切なトレイトを選択する
  - deriveマクロで自動実装できない場合は手動実装を検討する
  - トレイト間の整合性を保つ
  - パフォーマンスへの影響を考慮する

### 項目11：RAIIパターンにはDropトレイトを実装しよう

- RAIIパターンの特徴
  - コンストラクタで資源へのアクセスを確保する
  - デストラクタで資源へのアクセスを解放する
  - 不変条件として、アイテムが存在する間のみ資源へのアクセスが可能である
  - コンパイラがスコープ終了時の資源解放を保証する

- RAIIパターンの利点
  - コードのメンテナンス性が向上する
  - 資源の確保と解放が自動的に行われる
  - エラー処理時も資源の解放が保証される

- Dropトレイトの実装
  - RAIIパターンを実現するための中心的な機能である
  - dropメソッドは&mut selfを受け取る
  - 明示的な呼び出しはできず、コンパイラが自動的に呼び出す
  - 解放処理に対するエラー処理が必要な場合は別途releaseメソッドを実装する必要がある（返り値がないため）

- 主な用途
  - OSの資源管理（ファイルディスクリプタなど）
  - 同期用の資源管理（ミューテックス、ロックなど）
  - 低レベルのメモリ管理（FFIなど）

### 項目12：ジェネリクスとトレイトオブジェクトのトレードオフを理解しよう

- ジェネリクスとトレイトオブジェクトの基本的な違い
  - ジェネリクス：コンパイル時に型ごとに単相化された関数を生成する
  - トレイトオブジェクト：実行時に動的ディスパッチを行うvtableを使用する

- ジェネリクスの特徴
  - コードサイズが大きくなる傾向がある
  - メソッド呼び出しが若干高速
  - コンパイル時間が長くなる
  - 複数のトレイト制約を組み合わせやすい

- トレイトオブジェクトの特徴
  - コードサイズを抑えられる
  - vtableによる間接参照が必要
  - 複数のトレイトの組み合わせが困難
  - オブジェクト安全性の制約がある
    - ジェネリックメソッドを含めない
    - Self型の使用に制限がある

- トレイトオブジェクトが有効なケース
  - コードサイズやコンパイル時間が問題になる場合
  - 異なる型のオブジェクトを1つのコレクションで扱う場合
  - 実行時に動的にコードをロードする場合

- 選択の指針
  - パフォーマンスが重要な場合は実測して判断する
  - 複数のトレイト制約が必要な場合はジェネリクスを選ぶ
  - 型の異種混合が必要な場合はトレイトオブジェクトを選ぶ

### 項目13：デフォルト実装を用いて、実装しなければならないトレイトメソッドを最小限にしよう

- トレイトの2種類の利用者
  - トレイトを「実装する」プログラマ
  - トレイトを「使用する」使用者

- トレイト設計における対立関係
  - 実装者のために最小限のメソッドにしたい
  - 使用者のために多様なメソッドを提供したい
  - デフォルト実装によってこの対立を解決できる

- デフォルト実装の特徴
  - 基本的なメソッドを使って高度な機能を構築できる
  - 必要に応じて実装者がオーバーライド可能である
  - トレイト制約と組み合わせて使用できる

- 標準ライブラリでの活用例
  - ExactSizeIteratorのis_empty()メソッド
  - Iteratorトレイト（next()のみ必須で50以上のデフォルトメソッドを提供）
  - cloned()メソッドでのトレイト制約との組み合わせ

- デフォルト実装のメリット
  - 実装者は最小限のメソッドのみを実装すればよい
  - 使用者は豊富な機能を利用できる
  - 後方互換性を保ちながらメソッドを追加できる

## 3. さまざまなコンセプト

### 項目14：生存期間を理解しよう

- 生存期間の基本概念
  - すべての参照には生存期間が関連付けられている
  - 出力の生存期間は入力の生存期間に包含される必要がある
  - 生存期間は参照の有効範囲を示す
  - プログラマが生存期間についてできることは、名前をつけて、複数の生存期間が同じであることを示すことだけ

- 生存期間省略ルール
  - 1入力1出力の場合：出力は入力と同じ生存期間を持つ
  - 複数入力0出力の場合：入力はそれぞれ異なる生存期間を持つ
  - &selfを含む場合：出力は&selfと同じ生存期間を持つ

- 'static生存期間の特徴
  - プログラム全体で有効な生存期間を示す
  - staticなグローバル変数への参照に使用される
  - Box::leakによってヒープ上の値に付与できる

- ヒープ上の値の生存期間
  - 所有者の生存期間に紐づく
  - スタック上の変数かstaticで所有の連鎖が終わる
  - 所有者がドロップされると値もドロップされる

- データ構造と生存期間
  - 参照を含む構造体には生存期間パラメータが必要
  - 生存期間パラメータは伝染する
  - 可能な限り所有するデータ構造を使用すべき
  - 無名生存期間'_で生存期間の存在を明示できる

- Rust はさまざまな状況で、アイテムをスタック上のある場所から別の場所に移すこともある
し、スタックからヒープへ、ヒープからスタックへと移すこともある。

## 4. 依存ライブラリ

## 5. ツール

## 6. 標準Rustの向こうへ
