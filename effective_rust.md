# Effective Rust

## Links

- [Effective Rust](https://www.oreilly.co.jp//books/9784814400942/)

## 1. 型

### 項目1：データ構造を表現するために型システムを用いよう

- Rustの型システムは、他の静的型付け言語に馴染みがある
- isizeとusizeはポインタサイズと一致する
- Rustでは整数型の変換は明示的に行う必要がある
- 配列、タプル、構造体などの集約型が用意されている
- enum型は相互に排他な値の集合を指定するために用いられる
- enumは個々のヴァリアントにデータを付加できる
- Option<T>とResult<T, E>は非常に一般的なenum型である
- match式で型安全性を確保する
- **型で無効な状態を表現できないようにする**ことが重要
- Rustの型システムを用いて設計の意図を明確に伝える

### 項目2：型システムを用いて共通の挙動を表現しよう

- `fn`型は`Copy`と`Eq`を実装し、`std::fmt::Pointer`も実装する
  - 例: `let op1 = op; let op2 = op; assert!(op1 == op2); println!("op = {:p}", op);` 出力例: `"op = 0x101e9aeb0"`

- 関数の名前だけでは`fn`型にならず、明示的な自動型変換が必要である
  - 例: `let op1 = sum; let op2 = sum;` はコンパイルエラーになる
  - エラーメッセージ: `error[E0369]: binary operation == cannot be applied to type fn(i32, i32) -> i32 {main::sum}`

- クロージャは関数定義のボディ部のように見えるコード片（ラムダ式）である
  - 式の一部にできるため、名前を付ける必要がない
  - 入力引数はバー（|）で囲って与える
  - 包含する環境の一部をキャプチャできる

- 例: `let amount_to_add = 3; let add_n = |y| { y + amount_to_add }; let z = add_n(5); assert_eq!(z, 8);`

- コンパイラがラムダ式で参照されている環境の部分を保持した特注の内部型を作成し、クロージャが作成されると、この一時的な型のインスタンスが作られ、関連する値が格納される

- クロージャを関数ポインタの代わりに使うことはできない
  - エラーメッセージ: `error[E0308]: mismatched types`

- Rustには3種類のFn*トレイトがある
  - `FnOnce`: 1度だけ呼び出せるクロージャ
  - `FnMut`: 繰り返し呼び出せるクロージャ（環境を可変借用）
  - `Fn`: 繰り返し呼び出せるクロージャ（環境を共有借用）

- 例: `pub fn modify_all<F>(data: &mut [u32], mut mutator: F) where F: FnMut(u32) -> u32 { for value in data { *value = mutator(*value); } }`

- トレイトは関数のシグネチャだけでなく、関数の意図を表現するための機構である
- トレイトを実装する型は、トレイトのすべての関数を実装しなければならない

- 例: `pub trait Sort { fn sort(&mut self); } pub trait StableSort: Sort {}`

- Rustの型システムにおけるトレイトの使い方
  - トレイト制約として用いる。ジェネリック型や関数の型をコンパイル時に制約する
  - トレイトオブジェクトとして用いる。格納や関数に渡す型を実行時に制約する

### 項目3：OptionとResultに対してはmatchを用いずに変換しよう

- match式を使わずに変換メソッドを使用する利点
  - よりコンパクトで定型的なコードになる
  - 意図がはっきりとわかるコードになる

- 値のみが重要で、値がない場合は無視していい場合、if letを用いると明確になる
- 失敗時にpanic!を行う場合、unwrapとexpectメソッドを使用する
- クエスチョンマーク演算子?を使用してエラーを伝搬する
- エラーマッピングを行う場合、map_errメソッドを使用する
- Optionへの参照を、参照のOptionに変換する場合、as_refメソッドを使用する
- Resultにはmust_use属性があり、無視した場合はコンパイラが警告する
- ![OptionとResultの変換](https://oreil.ly/effective_rust_transforms)

### 項目4：標準のError型を使おう

- Result<T, E>のEにくるさまざまなエラー型をどう扱うかがテーマである
- すべてのエラーが同じ型であればその型を返せばよいが、異なる型のエラーがある場合にはサブエラーの型を保持する方法を決める必要がある
- std::error::Errorトレイトを実装することで、エラー型を統一することができる
- Errorトレイトを実装するためには、DisplayトレイトとDebugトレイトを実装する必要がある
- Errorトレイトの唯一のメソッドはsource()であり、内部にネストされたエラーを開示するために用いる
- String型をラップするタプル構造体を作成し、Errorトレイトを実装することができる
- すべてのサブエラー型にFromトレイトを実装しておくと便利である
- enumを使うことで、それぞれのエラーに関するすべての型情報を維持しつつコンパクトにエラー処理を行うことができる
- トレイトオブジェクトを使うことで、サブエラー情報を維持しつつ、すべての可能性のあるサブエラー型を手で書き出す必要がなくなる
- anyhowクレートを利用することで、エラー処理を簡素化し、スタックトレースなどの機能を提供することができる
- アプリケーションのエラー処理においては、様々なエラーをどのようにユーザに見せるかを一貫したエラー処理で実現するために、anyhowの利用を検討することが推奨される。一方で、ライブラリでは、具体的で詳細なエラー情報を出力し、パブリックAPIがanyhowに依存しないようにするため、ネストしたエラーを用いるべきである

### 項目5：型変換を理解しよう

- Rustの型変換は3つに大別される
  - 手動: ユーザがFromトレイトとIntoトレイトを実装して定義した型変換
  - 半自動: asキーワードを用いた明示的なキャスト
  - 自動: 暗黙のうちに行われる新しい型への自動型変換（coercion）

- 手動型変換
  - From<T>: 型Tのアイテムから作成でき、変換は常に成功する
  - TryFrom<T>: 型Tのアイテムから作成できるが、変換は失敗する可能性がある
  - Into<T>: 型Tのアイテムへ変換でき、変換は常に成功する
  - TryInto<T>: 型Tのアイテムへ変換できるが、変換は失敗する可能性がある

- ユーザ定義型の対応方針
  - 変換が失敗する可能性がある場合にはTry...トレイトを実装する
  - Fromトレイトを実装すると自動的にIntoトレイトも提供されるので、Fromを実装する
  - トレイト制約にはIntoを使う

- キャスト
  - asキーワードを用いた明示的なキャスト
  - 一般的な整数型間の変換が可能
  - from/intoで書くとコンパイラに拒絶される変換もある
  - 一貫性と安全性のためにfrom/intoによる変換を推奨する

- 自動型変換
  - ポインタと参照型に関する暗黙の変換が多い
  - DerefもしくはDerefMutトレイトを実装している場合に自動型変換が行われる
  - 具象型からトレイトオブジェクトへの変換も自動型変換の一つである

### 項目 6:newtype パターンを活用しよう

- newtypeパターンは、既存の型一つだけをフィールドとしてもつタプル構造体
  - 型エイリアスと違って、用途ごとに異なる型を定義できるので、誤った値を渡すことを防げる
    - 単位のセマンティクスを型に追加したり、真偽値の曖昧さを解消するためにも使える
  - #[repr(transparent)]属性により、メモリ効率、バイナリ互換性を損なわないことを保証できる
  - トレイトの孤児ルールを回避するためにも使える
- newtypeに対する全ての操作を、内部の型に転送しなければならない


## 2. トレイト

## 3. さまざまなコンセプト

## 4. 依存ライブラリ

## 5. ツール

## 6. 標準Rustの向こうへ
