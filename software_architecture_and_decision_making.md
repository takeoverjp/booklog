# ソフトウェアアーキテクトのための意思決定術

## Links

[ソフトウェアアーキテクトのための意思決定術](https://book.impress.co.jp/books/1123101159)

## 1. ソフトウェアリーダーシップ入門

- リーダー(ソフトウェアアーキテクト)は、リスクを最小限に抑えるやり方で不確実性を管理し、自分のビジョンと実現方法を人々に伝えて導かなくてはならない
- 優れたリーダーシップと、ソフトウェアアーキテクチャに対する優れた判断力の間にはギャップが存在している
- 本書の命題
  - 深く考え、ゆっくりと実装する
  - リーダーは同僚に押し付けることなく、不確実性を念頭に置きながらスコープを定義しなければならない

## 2. システム、設計、アーキテクチャを理解する

- ソフトウェアアーキテクチャのゴールは、品質基準を満たし、長期間または定められた期間で最高の投資回収率をもたらすシステムを構築すること
- 不確実性
  - ユーザとユーザの期待
  - システムの動作
  - ユースケースやユーザの変化
- 不確実性に対処するため、理解しやすく、柔軟性があり、不足の事態にも対応できるアーキテクチャを望む
- 常識が必要なのは下々の者、王者に必要なのは臨機応変さだ。

- コンテキストの理解を助け、適切な意思決定を行うための道標として機能する５つの質問と７つの原則
- 5つの質問
  - 市場投入に最適なタイミングはいつか？
  - チームのスキルレベルはどの程度か？
  - システムパフォーマンスの感度はどれくらいか？
  - システムを書き直せるのはいつか？
  - 難しい問題はどこにあるか？
- 7つの原則
  - ユーザージャーニーからすべてを導く
  - イテレーティブなスライス戦略を用いる
    - ライト兄弟は、まずうまく着陸できるグライダーを作り、強力なフィードバックサイクルを生み出すことで、限られた資金で資金力のある専門家たちを上回る成果を出した
  - 各イテレーションでは、最小の労力で最大の価値を加え、より多くのユーザーをサポートする
    - もっとも価値のあるいくつかのユースケースをサポートするために必要な機能だけを実装してリリースし、ユーザーフィードバックをもとに作り上げていく
    - 機能は出きる限り少なくする
    - なるべくミドルウェアやクラウドサービスを活用する
    - 抽象化はコストを加味して導入するかどうか慎重に判断する
  - 決定を下し、リスクをおう
  - 変更が難しいものは、深く設計し、ゆっくりと実装する
  - 困難な問題に早期に並行して取り組むことで、エビデンスに学びながら未知の要素を排除する
  - ソフトウェアアーキテクチャの凝集性と柔軟性のトレードオフを理解する
    - 凝集性を高めるために、依存関係追加に伴う複雑度の増加・コミュニケーションコストの増加が生じることも考慮する
    - 道具箱の中の道具として先述を考え、意味のあるときだけ使う

## 3. システムパフォーマンスを理解するためのモデル

- モデル１：ユーザモードからカーネルモードへの切り替えコスト
- モデル２：命令階層
- モデル３：コンテキストスイッチのオーバーヘッド
- モデル４：アムダールの法則
- モデル５：ユニバーサルスケーラビリティ法則
  - 共有変数の影響により、アムダールの法則が示すよりも実際の高速化が小さくなる
  - コヒーレンス：複数のプロセスやスレッド、ノード間の通信によって生じるオーバーヘッド
- モデル６：レイテンシーと使用率のトレードオフ
- モデル７：最大有用利用（MUU）モデルを使用したスループット設計
  - 以下の条件を満たすとき、スループットが最大になる
    - 各タスクが最適に実装されて
    - 無駄な処理がなく
    - もっとも貴重なリソースの使用率がもっとも高くなる
- モデル８：レイテンシー制御の追加
  - スループットを上げるためには使用率を100%に近づける必要があり、結果待ちが増えるのでレイテンシーは増加する
  - つまり、スループットとレイテンシーはトレードオフの関係にある
  - 与えられたレイテンシー要件に収まる範囲でスループットを高めるのが基本戦略となる

## 4. ユーザーエクスペリエンスを理解する

- 設定・API・拡張機能もUX
- UXの原則
  - ユーザーを理解する
  - 必要最小限のことをする
  - 良いプロダクトにはマニュアルがいらない
  - できるだけ求める情報を減らし、もっとも答えを得やすい方法で尋ねる
  - シンプルなものをシンプルにする
  - 実装の前にUXをデザインする

## 5. マクロアーキテクチャ：はじめに

- サービスの作り方、接続方法、配置の選択をマクロアーキテクチャとよぶ
- マクロアーキテクチャのビルディングブロック
  - データマネジメント
  - ルーターとメッセージング
  - エグゼキュータ
  - セキュリティ
  - 通信

## 6. マクロアーキテクチャ：コーディネーション

- 複数のサービスAPIを組み合わせて実現するとき連動するフローをコーディネーションと呼ぶ
- コーディネーション方法
  - クライアントからフローを駆動する
  - 別のサービスを利用する
  - 集中型ミドルウェアを使用する
  - コレオグラフィを導入する

## 7.マクロアーキテクチャ：状態の一貫性の保持

- トランザクションのベストプラクティス
  - できるだけ保証は限定的に
  - できるだけべき等に
  - できるだけトランザクションの範囲は限定的に
  - できるだけ読み出しと書き込みは同じサービスで
- トランザクションは複雑さを軽減する
- ほとんどのシステムではトランザクションマネージャーを必要とする
- トランザクションがパフォーマンス上の問題を引き起こす場合、保証を小さくするか、補償により問題を再定義することで、回避できる可能性がある

## 8. マクロアーキテクチャ：セキュリティ

- リソースをユーザーに見せておきながら、アクセスしたときにエラーにするのは、不快なUXになるので、認可においてはアクセス可能なリソースのリストが取得できなければならない
- 関連リスクがあるため、セキュリティについては最初シンプルに、というのは難しい
- セキュリティアーキテクチャの問題は、多くの場合レイテンシー問題として表面化する

## 9. マクロアーキテクチャ：高可用性とスケーラビリティ

- レプリケーションは、リソース消費と障害パスがあまりテストされないことという課題がある
- スケーラビリティを高めるための戦術
  - 何も共有しない
  - 分散させる
  - キャッシュする
  - 非同期に処理する

## 10. マクロアーキテクチャ：マイクロサービスアーキテクチャ

- 共有データベースをどうするか？
- 各サービスのセキュリティをどう実現するか？
- サービス間のコーディネーションをどう実現するか？
- 依存性地獄の避け方？
  - 後方互換性のサポートは必須条件
  - 前方互換性は回避すべき
- MSAはチームを分けるための戦略なので、小規模の人数で開発できるシステムでそのまま採用するのは避けるべき。サービスは一つ、リポジトリを分けるというてもある。

## 11. サーバーアーキテクチャ

- リクエストごとのスレッドアーキテクチャ
  - 実装は簡単
  - スレッド数が増えるので、コンテキストスイッチのオーバーヘッドが大きい
- イベント駆動アーキテクチャ
  - すべてをノンブロッキングにするのは難しい
  - IOの仕組みの理解が必須だが、理解している開発者はほとんどいない

- コーディネーションのオーバーヘッド
  - I/O: 複数のサービスからデータを更新するためにオーバーヘッドが生じる。単一ライターの原則
  - メモリアクセス：スレッド間のデータ交換に伴うオーバーヘッドや、複数サービスがメモリにアクセスすることで、キャッシュの偽共有によるオーバーヘッドが生じうる

- ローカルの状態を効率的に保存する
  - ディスクベース
  - メッセージキューベース
    - Apache Kafkaなど
      - ディスクベースよりシンプルなのでほとんどの場合ディスクベースより望ましい

- トランスポートシステム
  - HTTP
  - WebSocket, gRPC, HTTP/2
    - サーバプッシュ
  - AMQP
    - 永続性
  - 広くサポートされているという点で、HTTP, HTTP/2がオススメ
