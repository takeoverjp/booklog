# プログラマーのためのCPU入門

## Links

- [プログラマーのためのCPU入門](https://www.lambdanote.com/products/cpu)

## 1. CPUは如何にしてソフトウェアを高速に実行するのか

- CPUは、「命令を順番に並べたものに基づいて、データの読み書きと加工を行う機械」
- 現代の汎用CPUは、広く使うことができるように、多様なアプリで共通して必要になる小さな操作が基本的な粒度となるように命令が設計されている
- 現代のCPUでは、特別な指示がない限り記述順序で後続の命令を次に実行すれば良い、という前提を置くことで高速化を実現するために、処理したい順番に命令を並べる方式が採用されている

## 2. 命令の密度を上げるさまざまな工夫

- CPUは、命令の処理を複数のステージに分割している。その分割の仕方はCPUによって異なるが、本書では便宜的に「命令フェッチ」「命令デコード」「命令実行」の３ステージとする。
- 逐次実行は安全で確実な処理方式だが、ステージごとにみるといつも２サイクルの待ちが発生する
- パイプライン処理では、選考命令の完了を待たずに次の命令を次々開始する方式をさし、逐次実行と比べて実行効率を飛躍的に控除することができるが、先行する命令の実行結果に応じたキャンセルが必要になりCPU設計はは複雑になる
- Meltdownはキャンセル処理の不適切さによって生じたセキュリティホール
- 「命令の実行サイクル数」は、主に命令実行ステージの先頭を起点として数える
- パイプライン化したCPUに対して、更に並列度を高め、処理帯域を向上するための方法として、スーパースカラ化とスーパーパイプライン化がある
- スーパースカラ化は、1クロックで処理可能な各ステージの命令数を増やす
- スーパーパイプライン化は、パイプラインステージを更に細分化することで、1クロックを短くする
- いずれのアプローチでも、１つの命令を処理しはじめて終わるまでのリードタイムは変わらず、CPU設計は複雑になり、限界がある

## 3. データ依存関係

- ある２つの命令が、同一のレジスタやメモリ領域にアクセスする場合、その２つの命令間には「データ依存関係」があるという
- データ依存関係には、下記の４パターンがある
  - 真のデータ依存関係：ある命令の出力を後続の命令で入力として使う
  - 逆依存関係：ある命令の入力レジスタを、後続の命令の出力レジスタとして上書きする
  - 出力依存関係：ある命令と後続の命令の出力レジスタが重複している
  - 入力依存関係：ある命令と後続の命令の入力レジスタが重複している
- データの依存関係などにより、命令が実行できない無駄な空きサイクルのことを「ペナルティサイクル」と呼ぶ
- データの依存関係などにより、パイプラインの流れを妨げる要因や状況を「ハザード」と呼ぶ
- スーパーパイプラインでステージの分割段数を増やすほど、データ依存によるペナルティサイクルは増える
- スーパースカラで同時実行できるパイプライン数を増やせば増やすほど、データ依存による命令実行機会の影響は増える

- アウト・オブ・オーダー実行（真のデータ依存関係がない別の命令開始を前倒しする）ことで、命令実行機会損失を緩和できる
- ただし、命令を前倒しするためには、その命令の内容がわかっていなければならないので、命令のフェッチとデコードが完了していなければならない
- 命令フェッチから命令でコードのステージを、まとめてフロントエンドと呼ぶ
- アウト・オブ・オーダー実行で、本来書き換えてはいけないレジスタやメモリの内容を書き換えることを避けるため、命令の実行後に最順序化（リオーダー）が必要
- リオーダーでは、アウト・オブ・オーダー実行した命令の実行結果を別の場所に保持しておいて、改めて命令実行完了後に本来の順番でレジスタやメモリに反映する。ここで、実際にレジスタやメモリに反映するステージを、「命令コミットステージ」あるいは「命令リタイヤステージ」と呼ぶ
- 本来の命令の実行順序を記憶しておくためのテーブルを「リオーダーバッファ」と呼び、そのサイズがアウト・オブ・オーダー実行により同時に処理できる命令の数を制限する要因の一つである
- 逆依存関係と出力依存関係がある場合もそのままでは実行順序を入れ替えることができないが、出力レジスタを別の便宜上のレジスタに割り当てることで依存関係を解消し、実行順序を入れ替えることができる。この手法を「レジスタリネーム」と呼ぶ。便宜上のレジスタの個数も、アウト・オブ・オーダー実行により同時に処理できる命令の数を制限する要因の一つである
