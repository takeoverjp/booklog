# プログラマーのためのCPU入門

## Links

- [プログラマーのためのCPU入門](https://www.lambdanote.com/products/cpu)

## 1. CPUは如何にしてソフトウェアを高速に実行するのか

- CPUは、「命令を順番に並べたものに基づいて、データの読み書きと加工を行う機械」
- 現代の汎用CPUは、広く使うことができるように、多様なアプリで共通して必要になる小さな操作が基本的な粒度となるように命令が設計されている
- 現代のCPUでは、特別な指示がない限り記述順序で後続の命令を次に実行すれば良い、という前提を置くことで高速化を実現するために、処理したい順番に命令を並べる方式が採用されている

## 2. 命令の密度を上げるさまざまな工夫

- CPUは、命令の処理を複数のステージに分割している。その分割の仕方はCPUによって異なるが、本書では便宜的に「命令フェッチ」「命令デコード」「命令実行」の３ステージとする。
- 逐次実行は安全で確実な処理方式だが、ステージごとにみるといつも２サイクルの待ちが発生する
- パイプライン処理では、選考命令の完了を待たずに次の命令を次々開始する方式をさし、逐次実行と比べて実行効率を飛躍的に控除することができるが、先行する命令の実行結果に応じたキャンセルが必要になりCPU設計はは複雑になる
- Meltdownはキャンセル処理の不適切さによって生じたセキュリティホール
- 「命令の実行サイクル数」は、主に命令実行ステージの先頭を起点として数える
- パイプライン化したCPUに対して、更に並列度を高め、処理帯域を向上するための方法として、スーパースカラ化とスーパーパイプライン化がある
- スーパースカラ化は、1クロックで処理可能な各ステージの命令数を増やす
- スーパーパイプライン化は、パイプラインステージを更に細分化することで、1クロックを短くする
- いずれのアプローチでも、１つの命令を処理しはじめて終わるまでのリードタイムは変わらず、CPU設計は複雑になり、限界がある

## 3. データ依存関係

### 3.1 データ依存関係とは

- ある２つの命令が、同一のレジスタやメモリ領域にアクセスする場合、その２つの命令間には「データ依存関係」があるという
- データ依存関係には、下記の４パターンがある
  - 真のデータ依存関係：ある命令の出力を後続の命令で入力として使う
  - 逆依存関係：ある命令の入力レジスタを、後続の命令の出力レジスタとして上書きする
  - 出力依存関係：ある命令と後続の命令の出力レジスタが重複している
  - 入力依存関係：ある命令と後続の命令の入力レジスタが重複している

### 3.2 真のデータ依存関係のスーパーパイプライン化への影響

- データの依存関係などにより、命令が実行できない無駄な空きサイクルのことを「ペナルティサイクル」と呼ぶ
- データの依存関係などにより、パイプラインの流れを妨げる要因や状況を「ハザード」と呼ぶ
- スーパーパイプラインでステージの分割段数を増やすほど、データ依存によるペナルティサイクルは増える

### 3.3 真のデータ依存関係のスーパースカラ化への影響

- スーパースカラで同時実行できるパイプライン数を増やせば増やすほど、データ依存による命令実行機会の影響は増える

### 3.4 アウト・オブ・オーダー実行による緩和

- アウト・オブ・オーダー実行（真のデータ依存関係がない別の命令開始を前倒しする）ことで、命令実行機会損失を緩和できる
- ただし、命令を前倒しするためには、その命令の内容がわかっていなければならないので、命令のフェッチとデコードが完了していなければならない
- 命令フェッチから命令でコードのステージを、まとめてフロントエンドと呼ぶ

### 3.5 最順序化（リオーダー）の必要性

- アウト・オブ・オーダー実行で、本来書き換えてはいけないレジスタやメモリの内容を書き換えることを避けるため、命令の実行後に最順序化（リオーダー）が必要
- リオーダーでは、アウト・オブ・オーダー実行した命令の実行結果を別の場所に保持しておいて、改めて命令実行完了後に本来の順番でレジスタやメモリに反映する。ここで、実際にレジスタやメモリに反映するステージを、「命令コミットステージ」あるいは「命令リタイヤステージ」と呼ぶ
- 本来の命令の実行順序を記憶しておくためのテーブルを「リオーダーバッファ」と呼び、そのサイズがアウト・オブ・オーダー実行により同時に処理できる命令の数を制限する要因の一つである

### 3.6 真ではないデータ依存関係への影響を解消する

- 逆依存関係と出力依存関係がある場合もそのままでは実行順序を入れ替えることができないが、出力レジスタを別の便宜上のレジスタに割り当てることで依存関係を解消し、実行順序を入れ替えることができる。この手法を「レジスタリネーム」と呼ぶ。便宜上のレジスタの個数も、アウト・オブ・オーダー実行により同時に処理できる命令の数を制限する要因の一つである

### 3.7 ソフトウェアによる緩和

#### 3.7.1 レイテンシ仕様を知る

- 真のデータ依存関係による影響は、選考命令の実行レイテンシが長いほど大きくなる
- `mov`, `add`, `shift`といった単純な命令はたいてい1サイクルで実行が完了するのに対し、`mul`, `div`のような回路規模が複雑な演算や、`load`のようなメモリアクセスは数サイクル〜数十サイクルかかる
- GCCでは、各CPUのおおまかなレイテンシ値を命令スケジューリングに使用している

#### 3.7.2 レイテンシが長い命令を避ける

- 定数による除算であり、かつ、精度が許す場合、逆数の乗算とすることで、10サイクル以上のレイテンシがかかりうる除算を、数サイクルの乗算に置き換える
- 2のべき乗の乗算を、レイテンシがより短いシフト命令に置き換える

#### 3.7.3 レイテンシが長い命令が先行されるように配置する

- ソフトウェアパイプライニング最適化
  - ループにおける次の周回の一部の命令を、現在のループ周回に前倒しする
  - https://ja.wikipedia.org/wiki/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3

#### 3.7.4 真のデータ依存関係のない命令で埋める

- ループアンローリング最適化
  - 次の周回にある真の依存関係のない処理を、現在のループ周回で一緒に実行することで、無駄な空きサイクルを埋める
  - ループアンローリングをすることで、使用するレジスタが増え、レジスタ不足による性能劣化につながる可能性もある
