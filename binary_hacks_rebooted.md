# Binary Hacks Rebooted

## Links

- [Binary Hacks Rebooted](https://www.oreilly.co.jp/books/9784814400850/)

## 1. イントロダクション

### #1 未知のバイナリの読み方

- `file`, `hexdump -C`
  - `hexdump`で見ることで、制御文字も確認できる。マッチするはずの正規表現がマッチしない時は見てみると良いかも？
- `__attribute__((packed))`を付与することで、構造体をパディングせずに配置することを指示できる。デバイスドライバ等でC言語のアラインメントのルールに従えない場合に利用する。
- ELFでは4KiBでアラインメントをしている。これはページサイズに合わせることで、複数プロセス間のコードページ等の共有を用意にするため。

### #2 アセンブリ入門

- `objdump --disassembile=XXX`とすることで、`XXX`関数のみをディスアセンブルすることができる


### #3 Hello, World! 再訪

- 以下のようなメモリ上の領域を確保して、何らかの命令を実行する場合、そのバイト列は小さくてPICであることが必要
  - 領域に任意のバイト列を書き込むことができる
  - プログラムカウンタが指す先を領域の先頭に設定できる
  - 領域がどのアドレス範囲になるかは事前にわからない
  - 領域は比較的小さい

- 命令列を置くセクションと、文字列を置くセクションを同じにすることで、サイズを小さくする
- 文字列のアドレスをレジスタに入れる際に`call`命令を使うことで、PICを保ちながら`rsi`レジスタに代入することができる

## 2. ELF Hack

### #4 ELFファイルのセグメント

- ELFファイルには、３種類のヘッダがある
  - ELFヘッダ：残り２つのヘッダのオフセットや、OS/CPU architectureの情報
  - セクションヘッダ：リンカやデバッガ用。実行には必須ではない。
  - プログラムヘッダ：ダイナミックリンカやカーネル用。実行に必須。各セグメントについて対応するプログラムヘッダがある。

- `PT_NOTE`は`readelf --note hello`で確認でき、ビルドIDやOSの情報など、補助的な情報が入っている
- `PT_TLS`には、Thread Local Storage (TLS)の初期値が入っている
- `PT_GNU_RELRO`のセグメントは、ロードしたメモリの対応する範囲をリロケーションが終わったあとに読み込み専用にする。GOT Overwrite攻撃対策。RELROが普及するにつれて、lazy bindingは使われなくなりつつある。

### #5 ld-linux.soの環境変数を利用する

- 詳細は`man ld-linux.so`
- `LD_DEBUG=symbols`でシンボル解決の様子を確認できる
- `LD_AUDIT`環境変数で、ld-linux.soが新たにシンボルを束縛したときやPLTエントリ内の関数が呼び出されたときにユーザが登録したコールバックを呼び出すことができる

### #6 共有ライブラリを検索するディレクトリ

- `man ld-linux.so`
- `PT_DYNAMIC`セグメントの`DT_RPATH`フィールドは最も優先度が高いが、今は推奨されていない
- `LD_LIBRARY_PATH`環境変数が実質最も優先度が高いが、セキュリティ実行モードでは無視される
- `PT_DYNAMIC`セグメントの`DT_RUNPATH`フィールドを使うことで、実行バイナリと共有ライブラリをセットで配布する時に、自身の共有ライブラリを指定するためなどに利用する

- セキュリティ実行モード
  - 起動時の補助ベクトルに`AT_SECURE`タグを持つエントリが含まれる場合に、ダイナミックリンカはセキュリティ実行モードで動作する
  - setuidにより実行ユーザIDと実ユーザIDが異なる場合などに有効になる
    - `LD_LIBRARY_PATH`により任意のコードを実行できる状況を避けなければならない

### #7 dlopenによるライブラリの実行時ロードとその応用テクニック

- dlopen/dlsymの用途
  - ビルド時には存在しないライブラリを実行時にリンク／ロードする
  - プラグイン機構を提供する
  - `LD_PRELOAD`と組み合わせて、既存のライブラリ関数をラップする
  - `libc_start_main`関数をラップすることで、main関数の前に任意の処理（サンドボックスの初期化など）を差し込む

### #8 IFUNCを使って実行時に実装を切り替える

- `void XXX(void) __attribute__((ifunc("resolve_XXX")))`により、`XXX`のシンボル解決時に`resolve_XXX`が呼び出され、どの実装を使うかを選択することができる
- `main()`の前に呼ばれる関数の一つとして、IFUNCのresolver functionもある（他には`__attribute__((constructor))`やC++のグローバル変数のコンストラクタなど）
- glibcに依存する点に注意が必要

### #9 ELFのハッシュテーブルのしくみ

- 利用したいシンボルが共有ライブラリに存在するかどうかを知るため、検索するためのハッシュテーブルが共有ライブラリのPT_DYNAMICセグメントに存在する
- ハッシュテーブルのフォーマットには、`DT_HASH`, `DT_GNU_HASH`, およびその両方を保持する３パターンがある
- `DT_HASH`はPJWハッシュ関数を用いた素朴なハッシュテーブル
- `DT_GNU_HASH`は`DT_HASH`の性能を改善するため、ブルームフィルタによる一次フィルタ追加・ハッシュ関数をdjb2に変更という修正を行っている
- 書籍におけるダイナミックリンカのベンチマークでは、`DT_GNU_HASH`のほうが`DT_HASH`より2倍高速だった

### #10 TLSのしくみを理解する

- Thread Local Storageに保存した変数へのアクセスには、TLSアクセスモデルが使われる
- TLSアクセスモデルには、Thread Local変数が保存されているメモリ領域を参照するのに必要な情報を、いつ、どのように決めるかにより分類される
- TLSアクセスモデルには、主に以下の４つがある
  - Local Executable
    - 実行ファイルが、実行ファイルに含まれるThread Local変数にアクセスする場合
    - コンパイル時に決定する
    - 最も高速
  - Initial Executable
    - 実行ファイルが、共有ライブラリに含まれるThread Local変数にアクセスする場合
    - ロード時に決定する
  - General Dynamic
    - 共有ライブラリが、他の共有ライブラリや自分自身に含まれるThread Local変数にアクセスする場合
    - `__tls_get_addr`関数を使ってアクセス時に決定する
    - 最も汎用的だが、関数呼び出しのコストがかかる
  - Local Dynamic
    - 共有ライブラリが、１つの共有ライブラリの中にある複数のThread Local変数にアクセスする場合
    - １回だけ`__tls_get_addr`関数を使ってアクセス時に決定し、２回目以降はその結果を再利用する

### #11 コアファイルを読む

- コアファイルは単なるELFフォーマットのファイルである
- コアファイルは通常、複数のPT_LOADセグメントと１つのPT_NOTEセグメントからなる
- PT_LOADセグメントにクラッシュしたときのメモリの状態が保存される
- PT_NOTEセグメントには、主にメモリの状態以外の様々な情報が保存される
  - PT_NOTEセグメント中のNT_PRSTATUSには、クラッシュ時のレジスタの値（プログラムカウンタや関数引数）が保存される

### #12 補助ベクトルを使ってプロセスに情報を渡す

- `LD_SHOW_AUXV=1`もしくは`getauxval(3)`で確認できる
- SSP (Stack Smaching Protector) でスタックオーバーフローを検出するためのスタックカナリアの値として、`AT_RANDOM`を使っている
  - 他にもランダムな値を生成する方法はあるが、最も簡単であるため、この実装になっている
- 補助ベクトルは、プロセスのコマンドライン引数、環境変数、補助ベクトルの順にスタックに積むことで、kernelからプロセスに渡される

### #13 静的リンクとASLRの関係

- 普通に`-static`で静的リンクしたアプリケーションでは、ダイナミックリンカを経由せずに起動するため、ASLRが無効化される
- ASLRが無効化されていることは、`/proc/<PID>/maps`が変化しないことから確認できる
- `-static-pie`で静的リンクすることで、起動時のオーバーヘッドは大きくなるが、ASLRを有効にすることができる
- 静的リンクされたバイナリをPosition Independentにするためには、起動時のバイナリの書き換えが必要
  - 例：グローバル変数のアドレスを、別のグローバル変数に格納する
- 静的リンクされたバイナリはダイナミックリンカを経由しないので、自分自身で`_dl_relocate_static_pie`を呼び出すことで書き換える必要がある

### #14 soldを使って依存する共有ライブラリを後からリンクする

- 動的リンクされた実行ファイルを、他の環境に移植する時、依存ライブラリを含めてコピーするのは手間がかかる。
- soldを使えば、すでに動作している環境で動的リンクしている共有ライブラリを、静的にリンクすることで、実行ファイルの中に含め、移植性を高めることができる。
- soldは以下の手順で処理する
  - DT_NEEDEDフィールドの順に従い、依存する共有ライブラリを列挙する（順番が変わると、同名のシンボルの解決結果が変わってしまう）
  - 実行ファイルと共有ライブラリのPT_LOADセグメントを、相対的な位置関係を維持したまま１つの実行ファイルに含める
  - 再配置情報やTLS、例外処理のためのセグメントなど、１つのプログラムに１つしか存在できないものを新しく生成し、実行ファイルに含める
- [sold: A linker for shared objects](https://akawashiro.com/sold_kernelvm_20211120.pdf)

### #15 glibcをHackする

- ダイナミックリンカをシェルから起動して、実行したいELFバイナリを引数に渡すことで、標準とは異なるダイナミックリンカを使わず、明示的に指定することができる

### #16 patchelfでELFバイナリのフィールドを書き換える

- patchelfを使えば、ELFバイナリを再コンパイルすることなく書き換えることができる
- 例えば、下記のフィールドを編集できる
  - PT_INTERP: ダイナミックリンカ
  - DT_RUNPATH: 共有ライブラリの検索パス
  - DT_NEEDED: 依存する共有ライブラリ

### #17 LIEFをつかってELFバイナリを書き換える

- LIEFはpythonパッケージとして配布されている
- LIEFを使うことで、下記のようなELFファイルの書き換えができる
  - シンボルのrename
    - シンボル名は単に文字列としてバイナリに埋め込まれているだけでなく、シンボル検索用のハッシュテーブルにも影響する
  - 特定の関数を別の関数に差し替え

### #18 PT_NOTEを利用したバイナリパッチ

- PT_LOADをプログラムヘッダに追加することで、既存のバイナリが追加の命令列をメモリにロードするようにできる
- 単純にプログラムヘッダを追加すると、プログラムヘッダテーブル以降のオフセットがずれるため動かなくなる
- 動作に影響のないプログラムヘッダ（例えばPT_NOTEなど）を上書きすることで、オフセットをずらさずにPT_LOADを追加することができる

- `$((0x1000))`とすることで、shellで16進数を扱うことができる

### #19 DWARF Expressionを実行する : DWARF I

- DWARFにはいくつかの用途がある
  - デバッグ情報を表現する
  - C++などで例外が発生した際の大域脱出において、callee-savedレジスタの値を復元する手続きに相当する独自バイトコードをテーブルに含ませ、例外発生時に実行する

- `g++ -dA -fverbose-asm`で、読解するための補助コメントをつけたアセンブリファイルを生成する

- `DW_CFA_val_expression`命令により、レジスタの値を復元する際にDWARF Expressionを実行し、評価結果を使用することができるが、GNU Assemblerでは使えない
- このHackでは`.cfi_escape`という疑似命令でバイト列をDWARFバイトコードに埋め込む

### #21 DWARFで標準出力に出力する：DWARF III

- gccが生成したアセンブリ命令を変更しなくても、DWARF ExpressionだけでROPから処理を実行することができる
- すなわち、DWARF Expressionにバックドアをしかけることも理論的に可能なので、逆アセンブル結果を確認したプログラムであっても、信頼できないELFファイルはじっこうするべきではない

## 3. OS Hack

### #22 実行可能ファイルとその起動方法

- 狭義の実行可能ファイル：ELFフォーマットのバイナリファイル
- 本章での実行可能ファイル：ELFフォーマット、shebangを使うもの、binfmt_miscを使うものなど、シェルから実行できる全てのファイル

- ELF
  - PT_INTERPセグメントが存在しない場合、kernelがメモリ上にロードし、直接実行する
  - PT_INTERPセグメントが存在する場合、PT_INTERPセグメントに記載されたダイナミックリンカ(`ld-linux.so`)がELFを読み、書き換えたあと起動する
- shebang (`#!`)
  - shebangの解釈・実行はLinux kernelが行う
  - shebangには任意のプログラムを指定できるが、引数は１つしか指定できない
- binfmt_misc
  - shebangを含まない任意の形式のファイルを特定のプログラムで実行するための仕組み
  - ファイル中のマジックナンバーで判別する方法と、拡張子で判別する方法の２種類が用意されている
  - 使用例
    - 異なるアーキテクチャの実行ファイルを、それに応じたqemuで実行する
    - Linuxカーネルがデフォルトで認識できないファイルフォーマット(WebAssemblyなど)を対応するプログラムで実行する
  - binfmt_miscファイルシステムをmountし、`/proc/sys/fs/binfmt_misc`経由で設定する

### #23 LinuxでHuge Pageを使う

- TLBミスを減らすために、標準で4KiBのページサイズを2MiBや1GiBに増やすことができる
- 利用者があまり意識せずに使えるHuge PageのことをTransparent Huge Pageと呼ぶ
- `/sys/kernel/mm/transparent_hugepage/enabled`とglibcの環境変数`GLBC_TUNABLES`の`glibc.malloc.hugetlb=value`を介して設定可能
- 本書のサンプルでは、標準のページサイズでは97.6%TLBミスしていたストア処理が、THPを使うことで0.0%になり、実行時間も１４％程度削減できた
- 明示的にHuge Pageを確保することもできる

### #24 CRIUを使ってプロセスを保存、再開する

- CRIU(Checkpoint/Restore In Userspace)とは、Linuxのプロセスの状態をディスク上のファイルに保存し、そのファイルから再開することを可能にする
- CRIUでは、PIDやfdが継続して利用できる
- fdは通常のファイルの場合、再度openして、checkpointにおける読み出し位置までseekすることで実現する
- PIDは`/proc/sys/kernel/ns_last_pid`にcheckpointにおけるPID-1を書き込むことで実現する
  - `criu-ns`を使うことで、PIDが重複する場合にPIDネームスペースを作成することで対応することもできる

### #25 procfs / sysfs の基本を把握する

- `/proc/<TID>`は`getdents`の結果には含まれないが、直接オープンしたり`cd`するとアクセスできる
- 自分自身のスレッドの結果を取得するためには、`/proc/thread-self`が使える
- `/proc/<PID>/fd`以下のファイルに読み書きすることで、別のプロセスからデータを流し込めたりする
- `/proc/sys/vm/drop_caches`を使うことで、VMのメモリ使用量を減らしてホストのメモリ使用可能量を増やしたり、ディスクI/Oの正確なパフォーマンスを測定することができる

### #26 用途に合わせたファイルシステムを選ぶ

- Overlay Filesystem
  - 同じパスが複数のレイヤに存在する場合、上層のファイルが湯芋銭されて現れる
  - 下層由来のファイルに書き込みを行った場合、上層にコピーされた上で上書きが行われる。そのため、下層が読み取り専用でも書き込みが可能になる
  - 最上層以外はすべて読み取り専用
  - 効率的に差分保存を行えるため、ストレージ使用量を節約できる
  - Dockerで使われている
- Btrfs, Bcachefs (Copy-On-Writeファイルシステム)
  - コピー時点では参照だけ追加し、書き込みが発生した時点で最低限の実体のみ保存する。上書きの場合は差分だけを保存する。
  - BcachefsはCoWを含む多くの先進的な機能をもつ野心的なファイルシステム
- EROFS (Enhanced Read-Only File System, 圧縮ファイルシステム)
  - 高い圧縮性能とすばらしい読み取り性能が両立されている。同じく読み取り専用圧縮ファイルシステムとして以前よりあるSquashFSよりもランダムリードが高速。

### #27 特定のプロセスに見せるファイルを差し替える

- バインドマウントを使うことで、システム全体で一時的にファイルを置き換えることができる
- `unshare -m`で新しいマウントネームスペースを作成することで、特定のプロセスに対してのみバインドマウントすることができる
- マウントネームスペースの中で、overlayfsとバインドマウントをすることで、同じファイルを読み出しつつ書き込み先だけプロセスごとに変えることができる
  - モノリポでソースコードのパスを変更することは難しいが複数branch/version/configでビルドしたいようなときや、大規模プロジェクトでフルビルドするときにソースコードを完全に複数持つとストレージが厳しくなるがいろんなバリエーションでビルドしたいときなどに使えるかも

### #28 FUSEを使ってファイルシステムを自作する

- FUSEによりユーザ空間で動くプロセスとしてファイルシステムを実装することで、カーネルモジュールとして実装するより手軽にファイルシステムを作成・配布実行できる
- FUSEデーモンがサーバ、FUSEカーネルモジュールがクライアントとなり、FUSEプロトコルで通信することで、適切なファイル操作を実現する
- FUSEプロトコルは`/include/uapi/linux/fuse.h`および`man 4 fuse`に説明がある
- FUSEは一般的にパフォーマンスが通常のファイルシステムと比べて劣るが、下記のような軽減手法がある
  - FUSEマウント時のキャッシュオプションで、キャッシュの有効期間を長くする
  - FUSEデーモンをマルチスレッド化する
  - FUSEマウント時にDAX (Direct Access)オプションを指定することで、ファイルデータを共有メモリにmmapしオーバーヘッドを減らす
  - FUSE passthroughを使って、FUSEモジュールがFUSEデーモンを介さずに直接その下のファイルシステムとやり取りすることを許す仕組み

### #29 特殊なメモリ領域vsyscallとvDSO

- `vsyscall`はvirtual system callの意味で、当初はシステムコールと同等の処理をユーザランドだけで実現することで高速化する仕組みだった
- `vsyscall`は`sysexit`の戻り先やシグナルハンドラの戻り先など戻り先アドレスがわからないケースで、必ず`vsyscall`から呼び出すことで戻り先を定めるためにも利用されている
- `vsyscall`はLinuxカーネルが決まったアドレスに自動的にマップしていたので、セキュリティリスクがあることや、デバッガ等のツールが特別扱いしなければならないなどの課題を有していた
- `vDSO` (vsyscall Dynamic Shared Object)は、`vsyscall`を共有ライブラリ化することで、ASLRに対応し、またELFフォーマットとしてシンボル名やデバッグ情報を含められるようにしたもの

### #30 KVMを使ってハイパーバイザを作成する

- ハイパーバイザには、ハードウェア上で直接動作するType1と他のOS上で動作するType2がある
- LinuxのKVM (Kernel-based Virtual Machine)はType2ハイパーバイザ
  - Linux + KVMをType1ハイパーバイザとみなすこともできなくはないが、VMをLinuxの１プロセスとして実行して、リソース管理やスケジューリングをホストOSに任せているため、ここではType2とみなしている

- QEMUのようなエミュレータと比較して、
  - CPUのハードウェア仮想化支援機能を使うため、KVMの方がオーバーヘッドが少ない
  - 異なるCPU archのプログラムは実行できない
- `/dev/kvm`に対して`ioctl`でKVMのAPIを呼び出すことで、VMの作成・実行などの操作を行う
- QEMUも`--enable-kvm`フラグにより、KVMを使うハイパーバイザとして利用できる
- KVM APIの大まかな流れ
  - `/dev/kvm`を開く
  - `KVM_CREATE_VM`でVMを作成する
  - `KVM_CREATE_VCPU`, `KVM_GET_VCPU_MMAP_SIZE`などでVMの設定を行う
  - `KVM_RUN`でVMを実行する。`vmexit`が起こるまでブロックする
  - `KVM_RUN`が抜けたら(VMが実行できない処理(センシティブ命令)を実行した)`exit_reason`からなぜ`vmexit`が発生したかを確認し、それに応じた処理を行う

### #31 LinuxカーネルHack入門

- Linuxカーネルのソースコードを読む方法：
  - オンラインのクロスリファレンスサイト（例：bootlin）を利用
  - ローカル環境でGitリポジトリをクローン
  - cscopeやclangdなどのツールを使用してソースコードをナビゲート
- Linuxカーネルのビルド手順：
  - .configファイルの作成（make menuconfig、defconfig、localmodconfigなど）
  - makeコマンドでビルド
  - vmlinuxとbzImageファイルが生成される
  - `CC=`オプションにより、古いバージョンのGCCやClangでビルドすることもできる
  - `O=`オプションにより、Out-of-Source Buildすることもできる
- ルートディスクイメージの作成：
  - debootstrapを使用してDebianベースのrootfsを作成
  - ディスクイメージファイルを作成し、ext4ファイルシステムとして初期化
  - chrootを使用してrootfsの内容を変更可能
- QEMUでLinuxシステムをブート：
  - qemu-system-x86_64コマンドを使用
  - カーネルイメージ、ディスクイメージ、カーネルパラメータなどを指定
  - KVMを有効化して高速化
  - kernel起動オプションによりカスタムinitを利用することができる

### #32 Unikernel：アプリケーションをOSとして動かす

- Unikernelとは:
  - VMを前提としてアプリケーションに必要な機能に最適化されたカーネル
  - セキュリティ向上、ファイルサイズ・メモリ消費の効率化、起動時間の高速化、パフォーマンス向上を目指す
  - シングルメモリ空間アーキテクチャを採用し、カーネルとアプリケーションの分離を行わない

- ライブラリOS:
  - OS機能をライブラリとして提供
    - ライブラリと一緒に自分のアプリケーションをビルドするだけで、アプリケーションが直接VM上のカーネル空間でOSとして動作できるようになる
  - アプリケーションが必要なOS機能だけを組み込める
  - Unikernelの実現に使用される技術

- Unikraft:
  - 2017年にNECヨーロッパ研究所で開発開始されたUnikernel開発キット
  - 多くのプログラミング言語に対応
  - POSIX APIを提供し、既存アプリケーションの移植を容易に

- Unikraftの使用方法:
  1. Kraftfileの作成（プロジェクト設定）
  2. Makefile.ukの作成（ソースコード場所の指定）
  3. `kraft build`でビルド
  4. `kraft run`で実行（QEMUを使用）

- Unikernelの特徴:
  - 小さなフットプリント（例：Hello Worldプログラムで216KiB）
  - 通常のLinux VM(14MiB)と比較して大幅にサイズが小さい

- 注意点:
  - まだ実験的な技術であり、長期的なメンテナンスが保証されていない
  - コンセプトは普遍的だが、具体的な実装は変化する可能性がある

### #33 UEFIとSecure Boot

- mokutilにより、UEEIが定める変数（設定データ）の変数の読み出しができる

- UEFI変数の`PK`がRoot of Trustで、`KEK`が次のChain of Trustとなる

- DBXアップデータの署名を検証
  - DBXアップデータから署名部分とペイロード部分を展開
  - 署名部分に含まれる証明書を列挙
  - KEKの証明書で署名部分とペイロード部分を検証

- ブートローダの署名を検証
  - ブートローダから署名部分を展開
  - 署名部分に含まれる証明書を列挙
  - Root CAの証明書でブートローダを検証
  - ブートローダのハッシュ値をDBXと照らし合わせて、DBXに掲載されていないことを確認

- 失効したブートローダの検証
  - Fedoraが提供しているブートローダで、CVEなどを理由に失効したもので検証
  - 署名部分を展開し、証明書を列挙
  - Root CAの証明書で検証
  - ハッシュ値をDBXと照らし合わせて、DBXに掲載されていることを確認
  - DBXに掲載されているため、起動が未然に防がれる

### #34 GNUツールチェインで機械語ファイルを出力する

- ヘッダやリロケーション情報を含まないバイナリ列(binutilsにおける「バイナリファイル」)をそのまま機械語として解釈して実行する環境がある
  - 例: ArduinoやRaspberry Pi Pico、MS-DOSのCOMファイル
- binutilsに含まれるGNU ldを使用してバイナリファイルを生成可能
- リンカスクリプトを使用してバイナリファイルを出力する方法
  - SECTIONSコマンドで入力セクションと出力セクションの対応を記述
  - OUTPUT_FORMATコマンドで出力ファイルのフォーマットを指定
    - `"binary"`を指定することで、バイナリファイルを出力できる
- C言語に対応したリンカスクリプトの例
  - 機械語: .text
  - constデータ: .rodata
  - 読み書きする初期値ありデータ: .data
  - 読み書きする初期値なしデータ: .bss
    - OSがある環境では、OSが.bssセクションを0クリアするが、OSがない環境では自分で0クリアする必要がある
    - 0クリアするために.bssセクションのアドレスをプログラムから取得できるよう、リンカスクリプトではシンボルを定義することができる
- MS-DOSのエミュレータ上(`dosemu`)で"Hello, World!"を出力するバイナリファイルを生成する
  - MS-DOSが期待する0x100にプログラムが配置されるようリンカスクリプトを設定することで、MS-DSで動作するバイナリファイルを生成できる
  - MS-DOSでは、レジスタahに9を設定し、レジスタdxに$で終端されたバイト列を含むポインタを設定して、int 0x21を実行すると標準出力にバイト列を出力できる

### #35 QEMU上で動くファームウェアを作る

- 現代のコンピュータは、OSの実行開始前にハードウェアに合わせたプログラムが動く
- x86を搭載したPCでは、このプログラムはBIOSやUEFIと呼ばれる
- UEFIやBIOSは特別なプログラムではなく、通常のx86機械語で書かれている
- QEMUを使ってBIOSなしでプログラムを書く方法を紹介
- PCのファームウェアは、マザーボード上のSPI Flashに書かれていることが多い
- SPI Flashは、XIP（eXecute In Place）でアクセスできる
- x86は電源投入直後、プログラムカウンタが0xFFFF_FFF0に設定される
- QEMUは、ハードウェアを正確にエミュレーションし、BIOSやUEFIを起動する
- QEMUの`-bios`オプションで任意のファームウェアをロード可能
- 世界最初のIBM PCのBIOSに倣って、ファームウェアの最後の16バイトにlong jmp命令とリリース日を入れる風習がある（意味はない）
- PCではI/Oポート0x3f8がシリアルポートに紐付けられているので、QEMUの`-serial mon:stdio`を指定することで、標準出力にシリアル出力を表示できる
- QEMUのコマンドラインに'-action reboot=shutdown'を付けて、リセット時にQEMUのプロセスを終了させる

### #36 Chromebook 上で自作のファームウェアを 動かす

- chromebookは署名の検証に失敗しても起動する設定になっているので、書き換えたファームウエアを実行できる

## 4. コンテナHack

### #37. Linuxネームスペースでプロセスを分離する

- コンテナはプロセスの実行環境であり、隔離とリソースの制限が可能
- コンテナはカーネルを共有し、仮想マシンより軽量
- コンテナはLinuxの技術を組み合わせて実装されている
- Linuxネームスペースはプロセスの集合ごとにカーネルリソースを分離
- 8つのネームスペースがサポートされている
  - マウント、UTS(UNIX Time Sharing)、IPC、ネットワーク、PID、cgroup、ユーザー、Time
- システムコールでネームスペースを操作可能
  - clone、unshare、setns
- ネームスペースの外からは、ネームスペース内のプロセスも単なる一つのプロセスである
- ネームスペースはコンテナランタイム以外にも有用
  - 例: 特定のプロセスに見せるファイルを差し替える

### #38 cgroupでプロセスのリソースを管理する

- I/Oに対してcgroupを設定する場合、単純にスループットやIOPSでの制御では公平な配分が難しいので、IOCostという指標に基づいた重み付けでリソースを配分する方法がある

### #39 chroot/pivot_rootでルートディレクトリを切り替える

- chrootは脱出手段が複数あるので、セキュリティ用途で使ってはならない。セキュリティ用途ではpivot_rootを使う
- `pivot_root(2)`だけだと、procpfsが分離されないため、`/proc/PID/root`から元のルートディレクトリを見ることができてしまうので、PIDネームスペースも分離しなければならない。
- `pivot_root(2)`だけだと、デバイスファイルを作ることで、ディスクストレージにアクセスできてしまうので、cgroupでデバイスアクセスを制限しなければならない。

### #40 一般ユーザがrootのように振る舞う方法３選

- `setuid`, capability, ユーザネームスペース

### #41 rootlessコンテナの使い方とそのしくみ

- podmanはdockerとCLI互換のrootlessコンテナランナー
- ユーザネームスペースを使い、疑似root権限を使う
- 疑似root権限では、ユーザネームスペースの外に影響を与えることはできないが、新しくネームスペースを作ることはできる
- 新しく作成したマウントネームスペースについては、実際にmountすることができる（ユーザネームスペースの外には影響を与えないため）

### #42 ユーザーネームスペース内で各種のネームスペースを作成する

- ユーザネームスペース内外のユーザIDのマッピングは、`/proc/<PID>/uid_map`で設定できる
  - ただし、設定できるのは一回だけであることと、ユーザネームスペース内のUID１つに対し外のUIDが一つ以上必要である（ネームスペース内で複数UIDを使うためには外部の特権が必要になる）
- `newuidmap`, `newgidmap`コマンドを使うことで、一つのユーザネームスペース外UIDを複数のユーザネームスペース内UIDにマッピングできる
  - これは`newuidmap`に`setuid`しているから

- ユーザネームスペース内のマウントネームスペースでは、ext4など、ブロックデバイスやイメージファイルをマウントできない
  - ただし、FUSEを使うことでブロックデバイス等をマウントできる

- ユーザネームスペース内のネットワークネームスペースでは、外部通信ができない
  - `slirp4netns`により、通信をプロキシすることで外部通信を実現している
  - この方法には、well-known portのlistenができない、パフォーマンスが低下する、という課題がある

- ユーザネームスペース内のcgroupネームスペースは、外部でcgroupサブツリーを予め使うと言った協調動作が必要である

### #43 /proc/PID/rootからコンテナ内のファイルに直接アクセスする

- distrolessコンテナのようにshellを持たないコンテナで、ファイルを直接操作したい場合に、`/proc/PID/root`からコンテナ内のファイルに直接アクセスすることで代用できる
- 制約は以下の通り
  - コンテナの外から新たにマウントすることができない
  - コンテナの実行ユーザ(Dockerの場合は基本root)でないとアクセスできない

## 5. デバッガ・トレーサHack

### #44 gdb Tips

- `starti`により、ユーザランドのコードが実行され始める直前でブレークできる。ELFインタプリタをデバッグしたい場合や、共有ライブラリがロードされる瞬間を確認するのに有用
- `catch syscall`により、特定のシステムコールをトラップできる
- `catch signal`により、特定のシグナルをトラップできる
- `watch`, `rwatch`, `awatch`により、変数の値の変化をトラップできる
- `condition`により、ブレークする条件を指定できる
- `commands`により、ブレークしたときに自動で実行するコマンドを指定できる

- `set follow-fork-mode`により、forkした子プロセスをデバッグするかどうかを指定できる
- `set startup-with-shell`により、デバッグ対象のプロセスを起動したときにshell経由で起動するかどうかを指定できる

- `find`により、メモリの中の値を検索できる
- `dump`によりメモリの中味をファイルに出力し、`restore`によりファイルからメモリに復元できる

- `checkpoint`により、プログラムの実行状態をチェックポイントに保存でき、`restart`によりチェックポイントから実行再開できる
- `-tui`オプションをつけることで、テキストベースのインタフェースでデバッグできる
- `display`により、何らかの値を自動的に表示させることができる
- pythonでプラグインを作成できる
- `target extended-remote`により、組み込み機器のようにテキストインターフェースを持たない環境などでもリモートデバッグできる

### #45 rrを使ってRecord and Replayデバッグを行う

- rrは、プログラムの実行を記録し、その記録を再生することでデバッグを行うツール
- rrを使えば、プログラムの逆実行もできる(`reverse-continue`, `reverse-step`など)
- rrのオーバーヘッドはそこまで大きくなく、firefoxのデバッグにも使われている
- rrを使えば、マルチスレッドプログラムのような本来再現性の無い非決定的な動作でも、正確にデバッグできる

- rrは、対象となるソフトウェアの動作を、システムからの非決定的な入力と、それを元に決定的な計算をするCPU命令にわけ、システムからの非決定的な入力のみ記録することでオーバーヘッドを抑えている
- システムからの非決定的な入力は、下記の３種類である
  - システムコールの結果 : 基本はptraceだが、オーバヘッドを抑えるためseccomp-bpfでフィルタリングしたり、2回目以降は自ら記録するように対象プロセスを書き換えたりしている
  - スレッドやシグナルハンドラのコンテキストスイッチ
    - 同時に走るスレッド数を１つに制限することで、スレッドの実行順序を確定させる
    - そのため、マルチコア環境に依存した不具合は再現しない
    - マルチコア環境を最大限活かした並列プログラムでは、パフォーマンスへの影響が大きくなる
  - 非決定的なCPU命令
    - たとえば、乱数を返す`RDRAND`命令など

### #46 サニタイザで低レイヤのバグを見つける：サニタイザⅠ

- Rustは差に対座が実行時に堅守すつする多くのバグを、コンパイル時に検出したり、存在しないことを保証したりできる。一方で、Rustでもunsafeなコードのバグを発見するためにサニタイザも活用しようとしている
- ファジングを行うときに、サニタイザを有効にしたバイナリに対してファジングを行うことで、不正な挙動を動的に検知することが多い
- Valgrindは、再コンパイル不要なメリットがあるが、実行時オーバーヘッドがサニタイザより大きい

### #47 Address Sanitizerのしくみ：サニタイザⅡ

- Address Sanitizerは、下記の処理を追加する
  - メモリアクセスの可否を記録するshadow memoryを確保する
  - メモリ確保時に、隣接した領域にredzoneを確保し、redzoneはアクセス負荷であることをshadow memoryに記録する

### #48 Linuxパフォーマンス解析ことはじめ

- システムの挙動を観測する「可観測性ツール」には、下記の分類がある
  - イベントのカウント：イベントの発生回数およびその統計量を表示する。top, htop, iostat, perf statなど。
  - プロファイリング：定期的にスタックトレースを記録するなどにより、どの部分で時間がかかっているかを解析する。gprof, pprof, perf recordなど。
  - トレーシング：発生したイベントをタイムスタンプとともに記録する。strace, perf record, ftrace ,bpftace, perfetto, DBI/Intel PTなど。 

### #49 ftraceを使ってカーネル内で起こっていることをトレースする

- ユーザ空間からでも、ftraceのトレースイベントを記録することができる
  - `/sys/kernel/tracing/trace_marker`など

### #50 eBPFを使ったトレーシング入門

- libbpf-rsやAyaを使うことで、RustでeBPFプログラミングができる

### #51 DBIで実行命令をトレース・改変する

- DBI: Dynami Binary Instruction。対象プログラムに対して動的に実行命令のトレース・改変を行う
- 例えば、valgrind, DynamiRIO, Fridaなど

### #52: Intel PTで高速にトレースを取得する

- Intel PTは高速なプログラムトレースを提供するが、全命令をリアルタイムで保存するのは非現実的。
- Intel PTは必要最小限の情報をパケット形式で提供。
  
- **Intel PTのパケット種類**
  - **Target Instruction Pointer (TIP) パケット**: IPが変化した際に生成され、遷移先のアドレスを含む。
  - **Flow Update (FUP) パケット**: 非同期イベント(割込みや例外など)でIPが変化した際に生成。
  - **Taken Not-Taken (TNT) パケット**: 条件分岐命令実行時に生成され、分岐条件の成立 or 不成立を記録。
  - **MODEパケット**: プロセッサの実行モード(16,32,64ビットモードなど)に関する情報を提供。

- **トレース復元の必要性**
  - Intel PTから実際のトレースを復元するためには、逆アセンブルやデコーダが必要。
  - Intel PTは自己書き換えコードやJITコードには利用しにくい。

- **Intel PTの利用方法**
  - Intel PTはperfやgdbから利用可能で、自分でプログラムを実装することも可能。
  - `libipt`ライブラリを使用してパケットをデコード。

- **プログラムの実装例**
  - `/sys/bus/event_source/devices/intel_pt/type`を`open`してperfのファイルディスクリプタを取得する。
  - `trace_and_count`関数でlibiptを用いて実行された命令を取得する。
  - ASLRが無効化されている前提とすることで、実装を簡素化している。

## 6. セキュリティHack

### #53 seccompでプロセスが使えるシステムコールを制限する

- Docker, Chromeブラウザ, VMM (Virtual Machine Monitor)などで、実際に使われている

### #54 Landlockで非特権プロセスサンドボックスを作る

- Linux 5.13以降に導入された、root権限なしで利用できるサンドボックス機構
  - AppArmorやSELinuxはroot権限が必要だが、Landlockは非root権限でも利用可能
  - Stackable LSMとして実装され、他のLSMと共存可能

- Landlockの特徴
  - ファイルシステムやネットワークへのアクセス制限が可能
  - seccompと比べて適用が容易
    - パスベースでファイルアクセス制限を設定可能
    - システムコールレベルではなく、リソースの抽象度で制限を設定
  - カーネルで処理が完結するため、ptraceを使う手法より高速

- Landlockの使用方法
  1. 拒否したいファイル操作を定義したルールセットを作成
  2. 各パスごとに許可する操作を定義したルールを追加
  3. ルールセットをプロセスに対して有効化

- 注意点
  - 以下のシステムコールは制限できない(ABI v3時点):
    - chdir, stat, flock, chmod, chown, setxattr, utime, ioctl, fcntl, access
  - カーネルのバージョンによってサポートされる機能が異なる

### #55 ASLR 不正なメモリアクセスに対する防御機構

- ASLRを回避する攻撃手法
  - ランダマイズされない領域、エントロピーの少ない領域を攻撃する
  - 攻撃対象のアドレスを何らかの手段で知る(ログやforkなど)
  - 巨大な領域を確保することでエントロピーを下げる
  - mmpaが連続した領域を優先する特性を利用する

### #56 ROP：メモリ破壊を悪用するスタンダードな攻撃手法

- ROPは汎用的で、まず攻撃者はROPを狙う
- ASLRやstack protectorで難易度をあげることはできることができるが、根本的ではない

### #57 Intel CET：ROPに対するセキュリティ機構

- ROPは本質的には、リターンアドレスという制御用のデータと、演算対象のデータを同列に扱うことで生じている
- Intel CETでは、制御用のデータをshadow stackにあらかじめコピーしておくことで、改竄を検出する
- ヒープに置かれた関数ポインタを改ざんする攻撃をある程度緩和するために、Indirect Branch Trackingを導入している
  - IBTでは、関数の先頭に、`endbr32`や`endbr64`という命令を置くことで、正常な遷移先かどうかを実行時にチェックしている
- ソフトウェアによる検証もいくつか実装されているが、ソフトウェアにバグが発生しうること、TOCTOUリスクが生じること、オーバーヘッドが生じることから、ハードウェアによる対応のIntel CETが導入されている

### #58 Clang CFIによって不正な制御フローを検知する

- Clang CFIは関数ポインタやクラスオブジェクトのポインタの不正な使用を検知する機構
  - 関数ポインタの検査 (引数や戻り値の型のチェック、関数の開始アドレスのチェック)
    - スタブ関数を作成し、同じ型の関数のスタブを連続配置
    - アドレスの範囲とアライメントチェックで正当性を判定
    - 共有ライブラリの関数も検査可能だが、`dlopen`による動的ロードは不可

  - クラスオブジェクトの検査（オブジェクトのアドレスがキャストできるはずがない別のクラスのオブジェクトとして扱われていないかのチェック、不正なアドレスがオブジェクトのポインタとして扱われていないかのチェック）
    - vtableのアドレスをチェック
    - 64バイトアライメントで配置
    - クラスの継承関係とvtableのアドレスを把握しなければならないため、同一ファイル内のクラスのみ検査するよう、`-fvisibility=hidden`の指定が必要となる

  - 共有ライブラリ対応版(-fsanitize-cfi-cross-dso)
    - __cfi_check関数を追加
    - CFI Shadowでアドレスと検査関数の対応を管理
    - 検査対象の共有ライブラリもCFI対応が必要
    - 非対応ライブラリは検査をスキップ

### #59 スタックフレームの変化を観察する

- スタックフレームは関数呼び出し時に生成されるデータ構造
  - ローカル変数、リターンアドレス、引数などを保存する
  - セキュリティやパフォーマンス向上のためのコンパイルオプションを有効にすることで、スタックフレームの構造が変わる

- フレームポインタ：スタックフレームの底で、呼び出し元の関数のフレームポインタを指す
- スタックポインタ：スタックフレームの先頭

- フレームポインタの省略 (-fomit-frame-pointer)
  - スタックフレームサイズが固定の場合、ローカル変数にスタックポインタ+オフセットでアクセスすることで、フレームポインタが不要になる
  - 結果的にrbpレジスタを汎用レジスタとして使用できる
  - 可変長メモリ確保時は省略できない
  - スタックトレースをたどるときに、フレームポインタが使えないため、実装が複雑になる

- Stack Smashing Protector (SSP)
  - バッファオーバーフロー攻撃への対策
  - スタックカナリアを挿入し、関数終了時に改ざんを検知する

- Red zone
  - x86-64 ABIで定義された特別なメモリ領域(rsp-128からrsp-1)
  - シグナルハンドラや割り込みハンドラが書き換えない保証がある
  - leaf functionでローカル変数の保存に利用できる

### #60 ファジングの概要と分類

- ファジングはランダムテストを発展させたソフトウェアテスト手法である
  - ランダムな入力を生成してプログラムの異常動作を検出する
  - 主にネイティブバイナリを対象とし、セキュリティ分野で活用されている

- 対象プログラムの扱い方による分類
  - ブラックボックスファジング
    - プログラムの内部状態を取得せずにテストを行う
    - 適用が容易だが効率は低い
  - ホワイトボックスファジング 
    - シンボリック実行を用いて特定の実行パスを探索する
    - 複雑なパスも発見できるが、実行コストが高い
  - グレイボックスファジング
    - 実行時の内部状態をフィードバックとして利用する
    - コードカバレッジを指標とすることで効率的な探索が可能
    - 3種の中で最もバランスが良く、高性能である

- 入力生成方法による分類
  - Generation-based Fuzzing
    - 入力の文法を定義して生成する
    - 複雑な入力形式では記述コストが高い
  - Mutation-based Fuzzing
    - 既存の入力(シード)を改変して生成する
    - 汎用的で実装が容易なため主流となっている

- 代表的なツール
  - Honggfuzz: Googleが開発する高性能なグレイボックスファザー
  - AFL++: AFLの後継で、多くの研究成果を統合している
  - LibAFL: Rustで実装された拡張性の高いファジングライブラリ

### #61 グレイボックスファジングでバグや脆弱性を探す

- グレイボックスファザーAFL++を使用したファジングの実践例を解説する
  - 対象プログラムはformat string bugを含む脆弱性のあるプログラム
  - AFL++専用のコンパイラでビルドすることで計装を行う
  - 初期シードから開始して15分程度でprintf関数実行パスを発見
  - 25分程度でクラッシュする入力を発見

- グレイボックスファザーの動作の流れ
  - シード集合から1つ選択
  - ミューテーションによる入力の改変
  - 対象プログラムへの入力とフィードバック取得
  - フィードバックに基づくシードの保存判断
  - ファジング戦略の最適化

- AFL++におけるプロセス間通信の実装
  - 入力は標準入力またはコマンドライン引数から受け取る制約を設定
  - フィードバックはLLVM Passを用いた計装で実現
  - 共有メモリを使用してカバレッジ情報を受け渡し
  - ソースコードがない場合はQEMUやDBIツール、Intel PTなどで代替可能

### 63. libAFLで実装したファザーを改良する

- WeightedScheulerを使って、シードスケジューリングを改良する
- フォークサーバを用いて、システムコールを減らし、実行速度を改良する

### #64 angrでシンボリック実行する

- シンボリック実行の概要
  - プログラムの変数をシンボルとして扱い、実行パスを探索する手法である
  - 特定の実行パスを通過する入力を生成することができる
  - 制約の導出とSMTソルバーによる解決の2段階で動作する

- 代表的なシンボリック実行ツール
  - angr: マルチアーキテクチャ対応のバイナリ解析プラットフォーム
  - KLEE: LLVM Bitcodeに対して動作するエンジン
  - S2E: QEMUベースで選択的シンボリック実行を実現

- シンボリック実行の技術的課題
  - 外部環境とのインタラクション処理が必要
  - 実行パスの爆発的増加への対処
  - 変数依存のループや再帰、配列の扱い
  - メモリアクセスの解決
  - SMTソルバーの実行時間

- 課題への対処アプローチ
  - 具体的な実行結果を参考にした近似の活用
  - 入力の部分的な具体化による制約の簡略化
  - Dynamic Symbolic Execution(DSE)の採用

### #65 BadUSB：使用者を騙すUSBデバイス

- BadUSBの概要
  - 悪意のあるファームウェアを書き込んだUSBデバイスによる攻撃手法である
  - デバイスが自称する種類情報(USBディスクリプタ)を偽装することで実現する
  - 人間の認識とデバイスの実際の振る舞いの差を利用する

- 攻撃の具体例
  - USBメモリの外見でキーボードとして動作するデバイスの作成
  - 既存のUSBメモリのファームウェア改ざん
  - USBケーブルにICチップを埋め込む手法

- 実験による検証
  - Raspberry Pi PicoとCircuitPythonを使用
  - キーボードとして振る舞いWebページを自動で開く
  - プログラム次第で任意の操作が可能である

- 対策方法
  - コンピュータ側：USBGuardやMicrosoft Intuneによるデバイス制限
  - 使用者側：出所不明のUSBデバイスを接続しない
  - USB Type-C充電器にも注意が必要である

### #66 Row Hammer：DRAMの脆弱性に対する攻撃手法

- Row Hammerの概要
  - メモリ上のビットを不正に反転させる攻撃手法である
  - DRAMチップの物理的構造の脆弱性を利用する
  - ハードウェアの問題であり、ソフトウェアの脆弱性ではない

- 攻撃の仕組み
  - 特定のメモリ行(row)に対して連続的な読み込みを実行する
  - 近接する行の記憶素子に電磁的な影響を与える
  - ビット反転を引き起こし、システムに影響を及ぼす

- 攻撃手法の種類と進化
  - Single-sided Row Hammer：単一行への連続アクセス
  - Double-sided Row Hammer：隣接2行からの攻撃
  - TRRespass：TRR対策を回避する多数行からの攻撃

- 対策と課題
  - TRR(Target Row Refresh)による緩和策が実装されている
  - 新しい攻撃手法により完全な解決には至っていない
  - 物理的構造に起因する問題のため、根本的な解決が困難である

### #67 MeltdownとSpectre：CPUの脆弱性に対する攻撃手法

- 投機的実行の概要
  - 処理の順序を入れ替えて並列化することで最適化を行う技法である
  - 分岐結果を待たずに処理を先行実行する
  - 予測が外れた場合は処理を巻き戻す必要がある

- Meltdownの攻撃手法
  - Out-of-Order実行とキャッシュの観察を組み合わせた攻撃である
  - ユーザー空間からカーネル空間のメモリ内容を推定できる
  - 例外発生前の投機的実行結果がキャッシュに残ることを利用する

- Spectreの攻撃手法
  - 投機的実行を利用して情報を漏洩させる攻撃手法の総称である
  - MeltdownはSpectreのVariant3とされている
  - 分岐予測を誤らせて範囲外アクセスを引き起こす
  - JavaScriptからも実行可能でブラウザのサンドボックスを回避できる

- 影響と対策
  - 多くのCPUベンダーの製品が影響を受けた
  - ハードウェアとソフトウェアの両面から対策が実施された
  - パフォーマンスへの影響を伴う緩和策が導入された

## 7. 数値表現とデータ処理Hack

### #68 整数表現の基礎知識

- シフト演算の種類
  - 算術シフト：符号ビットを保持して右シフトする
  - 論理シフト：符号ビットに関係なく0を挿入する

- 符号拡張：ビット幅を広げる際に符号ビットを保持する

- レジスタと演算器の特徴
  - 64ビットアーキテクチャは64ビット幅のレジスタと演算器を持つ
  - x86-64は8/16/32/64ビットの演算をサポートしている
  - AArch64は主に32/64ビットの演算のみをサポートしている
  - 小さいビット幅の演算は、大きいビット幅の命令で代用される

### #69 さまざまな整数表現

- 任意精度数値型と多倍長表現
  - 計算機のネイティブ整数型を複数使用して任意のビット幅を表現する手法である
  - メモリが許す限り大きな整数を扱うことができる
  - GMPなどのライブラリで実装されている
  - PythonやHaskellなどでは組み込み型として提供されている

- 固定小数点数表現
  - 整数部と小数部に固定幅のビットを割り当てる表現方式である
  - 整数演算命令で実装できるため効率的である
  - 音声信号処理など、リソースの少ない環境での実数計算に使用される
  - AArch64ではssra命令による効率的な実装が可能である

- 可変長表現
  - 冗長な部分を除去して必要最小限のビット幅にパックする表現方式である
  - LEB128/VByteは7ビット単位でチャンク化する代表的なフォーマットである
  - DWARFやWebAssemblyで使用されている
  - SIMD命令を使用した高速なデコードが可能である

- Zig-zagエンコーディング
  - 符号付き整数を符号なし整数として扱える中間形式に変換する手法である
  - 符号付き整数と符号なし整数とで、エンコード・デコード処理を切り替える必要がなくなるメリットがある
  - 正負の値が交互に対応するため、この名称がついている
    - こういう名前の付け方はセンスを感じる。
  - Google Protocol Bufferなどで採用されている
  - 符号ビットを最下位ビットに移動させていると解釈することもできる

- UTF-8
  - Unicodeコードポイントの可変長エンコード形式である
  - コードポイントの値域に応じてチャンク分割を行う
  - バイト列の比較がコードポイントの順序を保持する
    - この工夫により、ASCII文字列用に実装された文字列比較関数を、UTF-8文字列にそのまま利用できる。すごい

### #70 浮動小数点数のビット列表現を理解する

- IEEE 754規格の基本
  - 浮動小数点数は仮数部(m)と指数部(e)で実数を表現する
  - x = (-1)^s × m × b^e の形式である
  - sは符号、bは基数(2または10)、mは仮数部、eは指数部を表す
  - 精度pと指数部の範囲eminからemaxを定めると浮動小数点形式が決まる

- IEEE 754の主な2進交換形式
  - binary16(半精度): 16ビット幅、精度11桁、emax=15
  - binary32(単精度): 32ビット幅、精度24桁、emax=127
  - binary64(倍精度): 64ビット幅、精度53桁、emax=1023
  - binary128(4倍精度): 128ビット幅、精度113桁、emax=16383

- 2進浮動小数点数のビット列表現
  - 符号部(1ビット)、指数部、仮数部下位に分かれる
  - 指数部はバイアスを加えて非負整数として表現する
  - 正規化数の仮数部は先頭の1を省略する(ケチ表現)
  - 特殊な値(0、非正規化数、無限大、NaN)は指数部の特殊値で表現する

- 10進浮動小数点数の特徴
  - decimal32/64/128の3つの交換形式がある
  - C言語では、10進浮動小数点数はC23で標準化されたが、処理系が実装するかどうかは任意である
  - 金融計算など、10進数での正確な計算が必要な場面で使用される
  - 人間が読み書きする数値を扱う場合に適している
  - 2進浮動小数点数では表現できない0.1などの10進数を正確に表現できる
  - Binary Integer Decimal(BID)とDensely Packed Decimal(DPD)の2つのエンコード方式がある
  - プラットフォームによってエンコード方式が異なる
  - 同じ数値であっても、末尾の0の数で異なる表現が可能

### #71 浮動小数点例外を理解する

- 浮動小数点例外の基本
  - IEEE 754で定められた5種類の例外がある
    - 不正な操作(invalid operation): 0/0や負の平方根の計算時に発生
    - ゼロ除算: 有限の数をゼロで割る時に発生
    - オーバーフロー: 結果が大きすぎて表現できない時に発生
    - アンダーフロー: 結果が小さすぎて正規化数で表現できない時に発生
    - 不正確(inexact): 結果を正確に表現できない時に発生
  - アーキテクチャによって独自の例外を追加定義している場合がある

- 例外の処理方法
  - デフォルトの処理
    - 対応する状態フラグを立てる
    - 無限大やNaN、非正規化数などを返して処理を継続
    - C言語ではfetestexcept/feclearexcept関数で状態フラグを操作可能
  - 代替処理方法
    - トラップ: プログラムの実行を中断する(x86やAArch64の一部で対応)
    - フラグを立てない: AVX-512のSAE(suppress all exceptions)など
    - flush to zero: アンダーフロー時に非正規化数の代わりにゼロを返す

- プラットフォーム依存の注意点
  - コンパイラの最適化による影響を避けるため#pragma STDC FENV_ACCESSの指定が必要
  - トラップの対応はCPUによって異なる
  - flush to zeroがデフォルトで有効な環境も存在する

### #72 浮動小数点数の丸め方を変える

- IEEE 754で規定された5つの丸め方
  - roundTiesToEven: 最近接偶数への丸め(デフォルト)
    - 最も近い浮動小数点数に丸める
    - 等距離の場合は仮数部最下位が偶数の方を選択
  - roundTiesToAway: 最近接遠方への丸め
    - 最も近い浮動小数点数に丸める
    - 等距離の場合は絶対値が大きい方を選択
  - roundTowardPositive: +∞方向への切り上げ
  - roundTowardNegative: -∞方向への切り下げ
  - roundTowardZero: 0方向への切り捨て

- 丸め方の指定方法
  - 動的な指定
    - fesetround関数で丸めモードを変更可能
    - 四則演算、型キャスト、sqrt系関数などに影響
    - パフォーマンス上の問題があり得る
  - 静的な指定
    - AVX-512やRISC-Vなど命令セット拡張で対応
    - C23では#pragma STDC FENV_ROUNDが規定された
    - CUDAなどGPU環境でも対応

- プラットフォーム依存の注意点
  - すべての環境で丸めモードの変更が可能とは限らない
  - WebAssemblyなど一部環境では非対応
  - roundTiesToAwayはハードウェア実装が少ない

### #73 浮動小数点環境を触るコードに対するコンパイラの最適化と戦う

- 浮動小数点環境を操作するコードの課題
  - コンパイラは通常、浮動小数点環境の操作を考慮せずに最適化を行う
  - 最適化によって意図した動作と異なる結果になることがある
  - 特に丸めモードの変更を伴うコードで問題が発生しやすい

- 対処方法
  - C標準のプラグマを使用
    - #pragma STDC FENV_ACCESS ONを指定
    - Clang 12以降で対応
    - GCCやMSVCは未対応
  - volatile修飾子の利用
    - 変数の読み書きタイミングを制御可能
    - メモリアクセスが増えパフォーマンスが低下する可能性がある
  - インラインアセンブリの利用
    - 変数アクセスのタイミングを厳密に制御可能
    - レジスタ割り当ても妨げない
    - コンパイラとアーキテクチャに依存する
    - glibcで採用されている手法

### #74 NaNを深掘りする

- signaling NaNの特徴と挙動
  - signaling NaNに対する演算で例外(FE_INVALID)が発生する
  - 関数のreturn時にquiet NaNに変換される可能性がある
  - C23でFLT_SNAN等のマクロが標準化された

- NaNのペイロードと伝播
  - NaNは符号1ビットと仮数部で多くの情報(ペイロード)を保持可能
  - 演算結果のNaNペイロードの伝播方法は実装依存
    - x86-64/AArch64: 左オペランドのNaNが伝播
    - x86-32: 最大のペイロードを持つNaNが伝播 
    - RISC-V: ペイロードは伝播せずカノニカルNaNとなる
  - コンパイラ最適化によって伝播の挙動が変わる可能性がある

- RISC-Vの浮動小数点レジスタとNaN
  - 単精度/倍精度で同じレジスタを共用
  - NaN boxing: 単精度使用時は上位ビットを1で埋める
  - 不正な値を単精度として読み取る場合はカノニカルNaNとなる

### #75 浮動小数点数のアーキテクチャごとの差異に触れる

- 浮動小数点数型の実装方式の違い
  - 高精度形式のみ命令提供し変換する方式
    - x87 FPUが採用
    - IEEE 754準拠の結果を得にくい
  - 各形式ごとに命令を提供する方式
    - 多くのアーキテクチャが採用
    - x86のSSE以降も採用

- アーキテクチャ依存の挙動
  - アンダーフロー判定のタイミング
    - x86/RISC-V: 丸めの後に判定
    - ARM: 丸めの前に判定
  - 融合積和演算(Fused Multiply Add) FMA(0, ∞, qNaN)の例外発生
    - x86: 例外を発生させない
    - ARM: 例外を発生させる
  - 浮動小数点数から整数への変換
    - x86: invalid operation例外を発生
    - ARM: JavaScriptやJava向けの専用命令を提供

- ARMの代替動作(FEAT_AFP)
  - x86互換の動作を選択可能
  - FMA例外やNaN生成などの挙動を変更可能

### #76 SIMD命令セットの基礎知識

- SIMD命令の概要
  - 1つのレジスタに複数データを保持し同時処理を行う
  - single-instruction multiple-dataの略
  - データ並列処理による高速化が可能である

- x86/x86-64のSIMD命令セット
  - MMX: 64bitレジスタを使用
  - SSE: 128bitレジスタを使用
  - AVX: 256bitレジスタを使用 
  - AVX-512: 512bitレジスタを使用
  - Intel SDMやIntrinsics Guideが参考になる

- ARMのSIMD命令セット
  - 32bit ARM
    - レガシーSIMD: 汎用レジスタを使用
    - NEON: 64/128bitレジスタを使用
  - 64bit ARM
    - NEON: 128bitレジスタを使用
    - SVE/SVE2: 128-1024bitレジスタを使用

- SIMD命令の利用方法
  - コンパイラに適切なアーキテクチャ指定フラグが必要
  - ISA世代指定/CPUマイクロアーキテクチャ指定/拡張命令セット指定などの方法がある
  - cpuid命令やcpu_featuresライブラリで実行時に対応命令セットを検出できる

### #77 SIMD並列化コードの実装方法

- SIMD並列化コードを書く前の準備
  - プロファイラを使用して実行プロファイルを取得する
  - プロセッサのマイクロアーキテクチャの詳細を理解する

- コンパイラの自動並列化の活用
  - -O3などの最適化オプションとアーキテクチャ指定フラグを組み合わせる
  - 配列演算などの自明な並列性を持つコードは自動ベクトル化が有効である
  - x86-64やARMで異なるSIMD命令セットを利用可能である

- OpenMP SIMDプラグマの利用
  - #pragma omp simdでSIMD並列化を指示できる
  - ループの制約や並列化の幅を明示的に指定可能である

- コンパイラのintrinsic関数の使用
  - 自動ベクトル化で満足できない場合に有効である
  - レジスタ割り付けなどの最適化はコンパイラに任せられる
  - 低レベルなSIMD並列化処理を記述できる

- SIMDラッパライブラリの活用
  - 複数のSIMD拡張命令セット向けに共通コードを記述できる
  - Highwayライブラリなどが代表的である
  - 複数アーキテクチャ対応が必要な場合に有効である

- アセンブリの手書き
  - 究極のパフォーマンスチューニングが可能である
  - レジスタ割り付けや命令の並び替えを完全制御できる
  - 最適化の阻害に注意が必要である

- JITライブラリの使用
  - 実行環境に応じた細かいチューニングが可能である
  - バイナリサイズの肥大化を防げる
  - XbyakなどのライブラリでSIMD命令を生成できる

### #78 SIMD命令を使ったさまざまなテクニック

- SIMD命令の文字列処理への応用
  - strlen関数の高速化実装例がある
  - SSE2命令を使用して\0を検出する
  - pcmpeqbとpmovmskb命令を組み合わせて効率的に処理する
  - ページ境界をまたぐ場合の特別処理も実装されている

- SIMD命令のデータ圧縮・展開への応用
  - VByte形式の可変長整数の展開を高速化できる
  - Masked VByteアルゴリズムが代表的である
  - pshufb命令を使って可変長データを整列させる
  - 継続ビットの処理にvpmovmskb命令を活用する
  - テーブル参照とSIMD演算を組み合わせて復元処理を行う

- その他の応用例
  - UTF-8などの文字列エンコーディング変換に活用できる
  - JSONパーサでの区切り文字検出にも利用される
  - pshufb命令は16要素のテーブル参照としても有用である

## 8. 言語処理系Hack

### #79 NaNを活用して64ビット値にタグ付きの値を格納する

- NaN boxingの概要
  - 64ビット値に倍精度浮動小数点数やポインタ等の値をタグ付きで格納するテクニックである
  - IEEE 754のNaNのビットパターンの一部を活用する
  - 8バイトで任意のタグ付き値を表現できる

- 実装方法
  - 最上位ビットを除く上位15ビットをタグとして利用する
  - 下位48ビットにデータを格納する
  - 0x7FF8以下は浮動小数点数を表す
  - 0x7FF9以上のタグで文字列ポインタや32ビット整数を表現する

- 実装例
  - uint64_tでタグ付き値を表現する
  - タグとビット論理和で値を格納する
  - マスク演算でタグとデータを取り出す
  - 文字列、整数、浮動小数点数を統一的に扱える

- 採用例
  - JavaScriptCore
  - LuaJIT
  - SpiderMonkey
  - Lua 5.2
  - mruby
  などの言語処理系で採用されている

- メリット
  - メモリ使用量を削減できる
  - 1つの値を8バイトで表現できる
    - 素朴に型情報とunionからなる構造体にすると、paddingが生じ、32bit環境で12byte, 64bit環境で16byte使ってしまう
    - 涙ぐましい努力。。。
  - 動的型付き言語の実装に適している

### #80 コルーチンの実装手法

- コルーチンの概要
  - 実行を途中で中断・再開できる機能である
  - 近年多くの言語で採用が進んでいる
  - C++20でもサポートが追加された

- ucontext.hによる実装
  - POSIXで提供されていた実行コンテキスト操作API
  - getcontext/setcontextでコンテキストの保存・復元を行う
  - makecontextで新しいコンテキストを作成する
  - swapcontextでコンテキストの切り替えを行う

- 簡易コルーチンライブラリの実装例
  - coro_createでコルーチンオブジェクトを作成
  - coro_resumeでコルーチンを実行
  - coro_yieldで実行を中断して値を返す
  - ucontext.hのAPIを活用してコンテキスト切り替えを実現

- スタックレスコルーチン
  - スタック全体ではなく必要な変数のみを保持
  - 言語処理系の協力が必要だが、オーバーヘッドが小さい
  - C++、Rust、JavaScriptなどで採用
  - 言語処理系の力を借りなくても、マクロを使った簡易実装も可能
    - とてもハッキーだが、PuTTYで実用されていた

### #81 Profile Guided Optimization

- Profile Guided Optimization（PGO）の概要
  - コンパイラ最適化の一種である
  - Feedback Directed Optimization（FDO）とも呼ばれる
  - プログラムを一度コンパイル・実行し、プロファイルを取得して最適化を行う

- PGOのメリット
  - プロファイル結果を活用することで、コンパイラはより高度な最適化を行える
  - 条件分岐の最適化により、命令キャッシュのヒット率や分岐予測の精度が向上する

- PGOの一般的な手順
  1. プログラムをプロファイル可能な形でコンパイルする
  2. 実行しプロファイルを取得する
  3. プロファイル結果を利用してPGOを有効化した上で再度プログラムをコンパイルする

- PGOの具体例
  - GCC、Clangの両方で利用可能
  - Clangを用いた具体例として、引数を表示するプログラムprintを題材にする
  - プロファイルを取得し、PGOを有効化して再コンパイルすることで、特定の引数に対して最適化されたバイナリを生成する

- [`hyperfine`](https://github.com/sharkdp/hyperfine)というツールにより、複数回コマンドを実行し、その結果を集計することができる

### #82 LD_PRELOADを使ってメモリアロケータを入れ替える

- 概要
  - 標準Cライブラリ以外のメモリアロケータを紹介
  - メモリアロケータを差し替えることでプログラムの性能向上が期待できる

- 代表的なメモリアロケータ
  - TCMalloc：Googleが開発、マルチスレッド環境での性能が良い
  - mimalloc：Microsoftが開発、KokaやLeanのランタイムシステムで使用
  - jemalloc：FreeBSDのlibcで使用、メモリのフラグメンテーションを避ける

- LD_PRELOADを使ったメモリアロケータの入れ替え方法
  - 既存のソフトウェアのメモリアロケータをLD_PRELOADで上書きする方法を紹介
  - 例としてfindコマンドのメモリアロケータをtcmallocに差し替え、プロファイル機能を使用

- 簡単なメモリアロケータの自作
  - mmapを使ってメモリを確保し、freeを無視する簡単なメモリアロケータを作成
  - LD_PRELOADで差し替えて動作を確認

### #83 ABIと呼び出し規約を理解する

- ABIと呼び出し規約の概要
  - ABI（Application Binary Interface）は、バイナリレベルでのプログラムの互換性を定義する
  - 呼び出し規約は、関数呼び出し時の引数の渡し方や戻り値の受け取り方を規定する

- 呼び出し規約の違い
  - Appleの呼び出し規約は、可変長引数をすべてスタックで渡す
  - x86-64 Linuxでは、可変長引数関数をプロトタイプなしで呼び出しても正常に引数が渡される
  - AArch64 macOSでは、プロトタイプなしの呼び出しでは正常に引数が渡されない

- 32ビットx86の呼び出し規約
  - cdecl：引数を右から左に積み、呼び出し側がスタックをpopする
  - stdcall：引数を右から左に積み、呼び出された側がスタックをpopする
  - thiscall：C++メンバー関数で使用され、thisポインタをecxレジスタで渡す

- 64ビット環境での可変長引数の実装
  - Microsoftのx86-64向け呼び出し規約では、shadow storeを使用して可変長引数を実装
  - System V ABIでは、va_listを複数のポインタで表現し、条件分岐を挟む

- C言語以外のABI
  - C++では名前のマングリング規則やthisポインタの呼び出し規約が含まれる
  - GoやSwiftなどの言語では、専用の呼び出し規約が存在する

## 9. そのほかのHack

- 
