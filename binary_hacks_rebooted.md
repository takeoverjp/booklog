# Binary Hacks Rebooted

## Links

- [Binary Hacks Rebooted](https://www.oreilly.co.jp/books/9784814400850/)

## 1. イントロダクション

### #1 未知のバイナリの読み方

- `file`, `hexdump -C`
  - `hexdump`で見ることで、制御文字も確認できる。マッチするはずの正規表現がマッチしない時は見てみると良いかも？
- `__attribute__((packed))`を付与することで、構造体をパディングせずに配置することを指示できる。デバイスドライバ等でC言語のアラインメントのルールに従えない場合に利用する。
- ELFでは4KiBでアラインメントをしている。これはページサイズに合わせることで、複数プロセス間のコードページ等の共有を用意にするため。

### #2 アセンブリ入門

- `objdump --disassembile=XXX`とすることで、`XXX`関数のみをディスアセンブルすることができる


### #3 Hello, World! 再訪

- 以下のようなメモリ上の領域を確保して、何らかの命令を実行する場合、そのバイト列は小さくてPICであることが必要
  - 領域に任意のバイト列を書き込むことができる
  - プログラムカウンタが指す先を領域の先頭に設定できる
  - 領域がどのアドレス範囲になるかは事前にわからない
  - 領域は比較的小さい

- 命令列を置くセクションと、文字列を置くセクションを同じにすることで、サイズを小さくする
- 文字列のアドレスをレジスタに入れる際に`call`命令を使うことで、PICを保ちながら`rsi`レジスタに代入することができる

## 2. ELF Hack

### #4 ELFファイルのセグメント

- ELFファイルには、３種類のヘッダがある
  - ELFヘッダ：残り２つのヘッダのオフセットや、OS/CPU architectureの情報
  - セクションヘッダ：リンカやデバッガ用。実行には必須ではない。
  - プログラムヘッダ：ダイナミックリンカやカーネル用。実行に必須。各セグメントについて対応するプログラムヘッダがある。

- `PT_NOTE`は`readelf --note hello`で確認でき、ビルドIDやOSの情報など、補助的な情報が入っている
- `PT_TLS`には、Thread Local Storage (TLS)の初期値が入っている
- `PT_GNU_RELRO`のセグメントは、ロードしたメモリの対応する範囲をリロケーションが終わったあとに読み込み専用にする。GOT Overwrite攻撃対策。RELROが普及するにつれて、lazy bindingは使われなくなりつつある。

### #5 ld-linux.soの環境変数を利用する

- 詳細は`man ld-linux.so`
- `LD_DEBUG=symbols`でシンボル解決の様子を確認できる
- `LD_AUDIT`環境変数で、ld-linux.soが新たにシンボルを束縛したときやPLTエントリ内の関数が呼び出されたときにユーザが登録したコールバックを呼び出すことができる

### #6 共有ライブラリを検索するディレクトリ

- `man ld-linux.so`
- `PT_DYNAMIC`セグメントの`DT_RPATH`フィールドは最も優先度が高いが、今は推奨されていない
- `LD_LIBRARY_PATH`環境変数が実質最も優先度が高いが、セキュリティ実行モードでは無視される
- `PT_DYNAMIC`セグメントの`DT_RUNPATH`フィールドを使うことで、実行バイナリと共有ライブラリをセットで配布する時に、自身の共有ライブラリを指定するためなどに利用する

- セキュリティ実行モード
  - 起動時の補助ベクトルに`AT_SECURE`タグを持つエントリが含まれる場合に、ダイナミックリンカはセキュリティ実行モードで動作する
  - setuidにより実行ユーザIDと実ユーザIDが異なる場合などに有効になる
    - `LD_LIBRARY_PATH`により任意のコードを実行できる状況を避けなければならない

### #7 dlopenによるライブラリの実行時ロードとその応用テクニック

- dlopen/dlsymの用途
  - ビルド時には存在しないライブラリを実行時にリンク／ロードする
  - プラグイン機構を提供する
  - `LD_PRELOAD`と組み合わせて、既存のライブラリ関数をラップする
  - `libc_start_main`関数をラップすることで、main関数の前に任意の処理（サンドボックスの初期化など）を差し込む

### #8 IFUNCを使って実行時に実装を切り替える

- `void XXX(void) __attribute__((ifunc("resolve_XXX")))`により、`XXX`のシンボル解決時に`resolve_XXX`が呼び出され、どの実装を使うかを選択することができる
- `main()`の前に呼ばれる関数の一つとして、IFUNCのresolver functionもある（他には`__attribute__((constructor))`やC++のグローバル変数のコンストラクタなど）
- glibcに依存する点に注意が必要

### #9 ELFのハッシュテーブルのしくみ

- 利用したいシンボルが共有ライブラリに存在するかどうかを知るため、検索するためのハッシュテーブルが共有ライブラリのPT_DYNAMICセグメントに存在する
- ハッシュテーブルのフォーマットには、`DT_HASH`, `DT_GNU_HASH`, およびその両方を保持する３パターンがある
- `DT_HASH`はPJWハッシュ関数を用いた素朴なハッシュテーブル
- `DT_GNU_HASH`は`DT_HASH`の性能を改善するため、ブルームフィルタによる一次フィルタ追加・ハッシュ関数をdjb2に変更という修正を行っている
- 書籍におけるダイナミックリンカのベンチマークでは、`DT_GNU_HASH`のほうが`DT_HASH`より2倍高速だった

### #10 TLSのしくみを理解する

- Thread Local Storageに保存した変数へのアクセスには、TLSアクセスモデルが使われる
- TLSアクセスモデルには、Thread Local変数が保存されているメモリ領域を参照するのに必要な情報を、いつ、どのように決めるかにより分類される
- TLSアクセスモデルには、主に以下の４つがある
  - Local Executable
    - 実行ファイルが、実行ファイルに含まれるThread Local変数にアクセスする場合
    - コンパイル時に決定する
    - 最も高速
  - Initial Executable
    - 実行ファイルが、共有ライブラリに含まれるThread Local変数にアクセスする場合
    - ロード時に決定する
  - General Dynamic
    - 共有ライブラリが、他の共有ライブラリや自分自身に含まれるThread Local変数にアクセスする場合
    - `__tls_get_addr`関数を使ってアクセス時に決定する
    - 最も汎用的だが、関数呼び出しのコストがかかる
  - Local Dynamic
    - 共有ライブラリが、１つの共有ライブラリの中にある複数のThread Local変数にアクセスする場合
    - １回だけ`__tls_get_addr`関数を使ってアクセス時に決定し、２回目以降はその結果を再利用する

### #11 コアファイルを読む

- コアファイルは単なるELFフォーマットのファイルである
- コアファイルは通常、複数のPT_LOADセグメントと１つのPT_NOTEセグメントからなる
- PT_LOADセグメントにクラッシュしたときのメモリの状態が保存される
- PT_NOTEセグメントには、主にメモリの状態以外の様々な情報が保存される
  - PT_NOTEセグメント中のNT_PRSTATUSには、クラッシュ時のレジスタの値（プログラムカウンタや関数引数）が保存される

### #12 補助ベクトルを使ってプロセスに情報を渡す

- `LD_SHOW_AUXV=1`もしくは`getauxval(3)`で確認できる
- SSP (Stack Smaching Protector) でスタックオーバーフローを検出するためのスタックカナリアの値として、`AT_RANDOM`を使っている
  - 他にもランダムな値を生成する方法はあるが、最も簡単であるため、この実装になっている
- 補助ベクトルは、プロセスのコマンドライン引数、環境変数、補助ベクトルの順にスタックに積むことで、kernelからプロセスに渡される

### #13 静的リンクとASLRの関係

- 普通に`-static`で静的リンクしたアプリケーションでは、ダイナミックリンカを経由せずに起動するため、ASLRが無効化される
- ASLRが無効化されていることは、`/proc/<PID>/maps`が変化しないことから確認できる
- `-static-pie`で静的リンクすることで、起動時のオーバーヘッドは大きくなるが、ASLRを有効にすることができる
- 静的リンクされたバイナリをPosition Independentにするためには、起動時のバイナリの書き換えが必要
  - 例：グローバル変数のアドレスを、別のグローバル変数に格納する
- 静的リンクされたバイナリはダイナミックリンカを経由しないので、自分自身で`_dl_relocate_static_pie`を呼び出すことで書き換える必要がある

### #14 soldを使って依存する共有ライブラリを後からリンクする

- 動的リンクされた実行ファイルを、他の環境に移植する時、依存ライブラリを含めてコピーするのは手間がかかる。
- soldを使えば、すでに動作している環境で動的リンクしている共有ライブラリを、静的にリンクすることで、実行ファイルの中に含め、移植性を高めることができる。
- soldは以下の手順で処理する
  - DT_NEEDEDフィールドの順に従い、依存する共有ライブラリを列挙する（順番が変わると、同名のシンボルの解決結果が変わってしまう）
  - 実行ファイルと共有ライブラリのPT_LOADセグメントを、相対的な位置関係を維持したまま１つの実行ファイルに含める
  - 再配置情報やTLS、例外処理のためのセグメントなど、１つのプログラムに１つしか存在できないものを新しく生成し、実行ファイルに含める
- [sold: A linker for shared objects](https://akawashiro.com/sold_kernelvm_20211120.pdf)

### #15 glibcをHackする

- ダイナミックリンカをシェルから起動して、実行したいELFバイナリを引数に渡すことで、標準とは異なるダイナミックリンカを使わず、明示的に指定することができる

### #16 patchelfでELFバイナリのフィールドを書き換える

- patchelfを使えば、ELFバイナリを再コンパイルすることなく書き換えることができる
- 例えば、下記のフィールドを編集できる
  - PT_INTERP: ダイナミックリンカ
  - DT_RUNPATH: 共有ライブラリの検索パス
  - DT_NEEDED: 依存する共有ライブラリ

### #17 LIEFをつかってELFバイナリを書き換える

- LIEFはpythonパッケージとして配布されている
- LIEFを使うことで、下記のようなELFファイルの書き換えができる
  - シンボルのrename
    - シンボル名は単に文字列としてバイナリに埋め込まれているだけでなく、シンボル検索用のハッシュテーブルにも影響する
  - 特定の関数を別の関数に差し替え

### #18 PT_NOTEを利用したバイナリパッチ

- PT_LOADをプログラムヘッダに追加することで、既存のバイナリが追加の命令列をメモリにロードするようにできる
- 単純にプログラムヘッダを追加すると、プログラムヘッダテーブル以降のオフセットがずれるため動かなくなる
- 動作に影響のないプログラムヘッダ（例えばPT_NOTEなど）を上書きすることで、オフセットをずらさずにPT_LOADを追加することができる

- `$((0x1000))`とすることで、shellで16進数を扱うことができる

### #19 DWARF Expressionを実行する : DWARF I

- DWARFにはいくつかの用途がある
  - デバッグ情報を表現する
  - C++などで例外が発生した際の大域脱出において、callee-savedレジスタの値を復元する手続きに相当する独自バイトコードをテーブルに含ませ、例外発生時に実行する

- `g++ -dA -fverbose-asm`で、読解するための補助コメントをつけたアセンブリファイルを生成する

- `DW_CFA_val_expression`命令により、レジスタの値を復元する際にDWARF Expressionを実行し、評価結果を使用することができるが、GNU Assemblerでは使えない
- このHackでは`.cfi_escape`という疑似命令でバイト列をDWARFバイトコードに埋め込む

### #21 DWARFで標準出力に出力する：DWARF III

- gccが生成したアセンブリ命令を変更しなくても、DWARF ExpressionだけでROPから処理を実行することができる
- すなわち、DWARF Expressionにバックドアをしかけることも理論的に可能なので、逆アセンブル結果を確認したプログラムであっても、信頼できないELFファイルはじっこうするべきではない

## 3. OS Hack

### #22 実行可能ファイルとその起動方法

- 狭義の実行可能ファイル：ELFフォーマットのバイナリファイル
- 本章での実行可能ファイル：ELFフォーマット、shebangを使うもの、binfmt_miscを使うものなど、シェルから実行できる全てのファイル

- ELF
  - PT_INTERPセグメントが存在しない場合、kernelがメモリ上にロードし、直接実行する
  - PT_INTERPセグメントが存在する場合、PT_INTERPセグメントに記載されたダイナミックリンカ(`ld-linux.so`)がELFを読み、書き換えたあと起動する
- shebang (`#!`)
  - shebangの解釈・実行はLinux kernelが行う
  - shebangには任意のプログラムを指定できるが、引数は１つしか指定できない
- binfmt_misc
  - shebangを含まない任意の形式のファイルを特定のプログラムで実行するための仕組み
  - ファイル中のマジックナンバーで判別する方法と、拡張子で判別する方法の２種類が用意されている
  - 使用例
    - 異なるアーキテクチャの実行ファイルを、それに応じたqemuで実行する
    - Linuxカーネルがデフォルトで認識できないファイルフォーマット(WebAssemblyなど)を対応するプログラムで実行する
  - binfmt_miscファイルシステムをmountし、`/proc/sys/fs/binfmt_misc`経由で設定する

### #23 LinuxでHuge Pageを使う

- TLBミスを減らすために、標準で4KiBのページサイズを2MiBや1GiBに増やすことができる
- 利用者があまり意識せずに使えるHuge PageのことをTransparent Huge Pageと呼ぶ
- `/sys/kernel/mm/transparent_hugepage/enabled`とglibcの環境変数`GLBC_TUNABLES`の`glibc.malloc.hugetlb=value`を介して設定可能
- 本書のサンプルでは、標準のページサイズでは97.6%TLBミスしていたストア処理が、THPを使うことで0.0%になり、実行時間も１４％程度削減できた
- 明示的にHuge Pageを確保することもできる

## 4. コンテナHack

- 

## 5. デバッガ・トレーサHack

- 

## 6. セキュリティHack

- 

## 7. 数値表現とデータ処理Hack

- 

## 8. 言語処理系Hack

- 

## 9. そのほかのHack

- 
