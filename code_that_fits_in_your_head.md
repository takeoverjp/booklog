# 脳に収まるコードの書き方 ～複雑さを避け持続可能にするための経験則とテクニック

- [link](https://www.oreilly.co.jp//books/9784814400799/)

## 1. 加速

### 1. アートかサイエンスか

- 建築のメタファは、ソフト開発を終わりのあるものと誤解させる
- 実際には、リリース後であれ思い立ったらすぐにリリースできる能力が求められるもの
- ソフト開発における実装は、実際に建築するフェーズと対応付けられることで、交換可能な作業と誤認させる
- ソフト開発における実際の建築相当はコンパイルであり、実装は設計の要素を多分に含む
- 知識体系を身に付けないままプログラマーになる大衆文化が増加したことで、歴史が軽んじられる

### 2. チェックリスト

- チェックリストを使うことで、スキルの向上なしに結果を改善できる
- `git commit --allow-empty -m "Initial commit"`で、空のコミットを最初に追加することができる

- 新規コードベースのためのチェックリスト
  - Gitを使え
  - ビルドを自動化せよ
  - エラーメッセージをすべて有効にせよ

### 3. 複雑さに対処する

- コードは書く回数より読む回数の方が多いので、可読性のために最適化せよ
  - どんな馬鹿でもコンピュータが理解できるコードをかける。良いプログラマーは人間が理解できるコードを書く

### 4. バーティカルスライス

- 考えつく中で一番シンプルな機能をユーザーインターフェイスからデータストアまで全部実装することで、ソフトウェアが動くかどうかをなるべく早く確かめる。そこから広げていく
- データベーススキーマもGitリポジトリにコミットする

### 5. カプセル化

- カプセル化とは、オブジェクトと呼び出し側の有効なやりとりを記述する契約
  - オブジェクトは、オブジェクト自身が無効な状態に決してならないことを保証するべき
  - 契約は事前条件（呼び出し側の責任）と事後条件（オブジェクトによって与えられる保証）
  - 呼び出し側に求めることが少ないほど、呼び出し側はオブジェクトとのやり取りが簡単になる
- ポステルの法則
  - 送るものは慎重に、受け取るものは寛容に
  - もとはTCPのコンテキストで提唱された法則だが、API設計でも役に立つ
  - API設計においては、受け取るものは意味のある処理をすることができる範囲において寛容に、受け取れない入力についてはすぐにエラーにすることになる
- オブジェクトが満たすべき不変条件は、誤った使い方を防ぐために外から変更できないように保護するべき
  - 例外の値・型はテストするべきだが、例外メッセージのテキストはテストするべきではない（オブジェクトのふるまいの一部ではないので、必要以上にテストと実装詳細を結びつけるべきではない）

### 6. 三角測量

- 明らかに不十分な実装でなんとかしてテストを全部成功させることで、十分なテストケースを書くことを自身に矯正させることができる
- テストが具体的になるほど、コードはより汎用的になる

### 7. 分解

- サイクロマティック複雑度は簡単に測定できて意味のある数少ない指標。値自体に特別意味がなくても、しきい値を設けてリファクタリングすることで腐敗を防ぐことができる
- サイクロマティック複雑度が７を超える場合はコミットしてはならない
- サイクロマティック複雑度は実行経路の数であり、最低１、ifなどがあるたびにインクリメントしていくことで算出できる
- メソッドの行数は24行まで、一行の長さは80文字まで
- どこで分解するかを検討する時は、凝集・特性の横恋慕・バリデーションに注目する

### 8. API設計

- 良いインターフェース設計をするには、何ができるかだけでなく、意図的にできなくすべきことも検討する
  - APIでは不正な状態をそもそも表せないようにする
- メソッド名で情報を伝えることは有用だが、ふるまいの変化には弱い。メソッド名がなくてもシグネチャで意味がわかるのが一番劣化しづらい
- コマンドとクエリを分離したAPI設計を心がける（CQS:コマンドクエリ分離）
  - コマンドとは、副作用を起こすことが目的のAPI。副作用が目的であることを明確にするために、変え位置はvoidにする。
  - クエリとは、返り値を得ることが目的のAPI。返り値を得ることが目的であることを明確にするために、副作用を起こさない。
- API設計のときに気をつけるべきこと
  - コンピュータが理解できるコードは馬鹿でも書けるが、良いプログラマーは人が理解できるコードを書く
  - 抽象化とは無関係なことを排除し、本質的なことを増幅するものである

### 9. チームワーク

- gitのコミットメッセージには、50/72ルールという事実上の標準がある

- コードレビューの心得
  - コードレビューで見るべきなのは、自分のペースでコードを読んだときに、読みやすいかどうか。自分でメンテナンスできるかどうか。レビュイーが変更点を説明するスタイルは、自分のペースでコードが読めないので、望ましくない
  - レビュー観点
    - コードは意図したとおりに動くか？
    - 意図は明確か？
    - 不要な重複はないか？
    - 既存のコードでこの問題を解決できないか？
    - もっとシンプルにできないか？
    - テストは包括的で明確化？
  - チームメンバーは全員がコードの作者になるとともに、他のメンバーが書いたコードのレビュアーになるべき。レビュアーになることは、一部の選ばれた人だけの特権でもなければ負担でもない
  - 気に食わないところを指摘するだけでなく、具体的な代替案を提示する
  - 気に入ったところは忘れずに喝采を送る
  - 文字のやり取りではトーンや意図が簡単に失われるので、必要以上に礼儀正しくして、友好的な態度を示すために絵文字を使う
  - 適切なレビューをするために必要な時間を取る。プルリクエストが大きすぎる場合は、圧倒されて承認するのではなく、プルリクエストを拒否する。
  - コードは自分のマシンにpullして、実行する

- プルリクエストを作る時の心得
  - プルリクエストをできる限り小さくする。あなたが思う以上に小さくする
  - １つのプルリクエストでは１つだけのことをする。複数のことをしたければ、別のプルリクエストに分ける
  - フォーマットを修正するだけのプルリクエストでなければ、フォーマットを修正しない
  - コードがビルドできることを確認する
  - 全てのテストが成功することを確認する
  - 新しいふるまいにはテストを追加する
  - 適切なコミットメッセージを書く

## 2. 持続可能性

### 10. コードの増大

- こまめにmainにmergeし続けられる進め方を選択する
  - フィーチャーブランチで開発するのではなく、フィーチャーフラグで機能を隠しつつ、頻繁に統合する
  - 大きめのリファクタリングが必要なときは、ストラングラーパターン（新しいコードと古いコードを共存できるようにして、徐々に置き換える）を使う
  - APIを公開しているのであれば、破壊的変更に敏感になり、バージョニングを考慮する

### 11. ユニットテストを編集する

- プロダクションコードにはテストというセーフティネットがあるが、テストコードにはセーフティネットが無いので慎重に編集しなければならない
  - テスト・アサーションの追加は安全
  - IDEによりリファクタリングするのも安全
  - テストとプロダクションコードのリファクタリングは、別々に実施する。それでもテストにまちがいがないことを保証はできないが、間違いが起こる可能性を減らすことができる
- 失敗したことのないテストを信用しない
  - トートロジー的なアサーションを書くのは驚くほど簡単
  - テストを変更したら、テスト対象システムを一時的にテストが失敗するように変える

### 12. トラブルシューティング

- 何が起こっているのかの理解に努めよ
  - 科学的手法：仮説→実験→仮説と実験結果の比較→考察を繰り返す
  - 対症療法のコードを追加するのではなく、コードをシンプルにすることで問題を解決できないかをまず考える
  - 解析中は時間を区切って定期的に休憩する。トラブルに対する質問文を書いてみることで、頭を整理する
- 欠陥数の理想値は０
  - 欠陥をテストとして再現する
  - 欠陥対応で難しいのは、欠陥の理解と再現
  - マルチスレッドに関わる問題のような非決定論的な欠陥は、繰り返しテストを実行してある一定のしきい値以上耐えられたら希望的観測でOKとするしかない。そのようなテストは時間がかかるため、パイプラインの後段で実施する
- 二分法で欠陥の原因を特定する
  - 時系列の二分法：`git bisect`
  - ソースコードの二分法：半分ソースコードを消して問題が起こるか？
- デバッグツールの使い方の前に、上記のような汎用的なプラクティスを習得すべき

### 13. 関心ごとの分離

- 同じ頻度で変更されるものは一緒に、違う頻度で更新されるものは別に
- 副作用のあるコマンド型のメソッドを内部で呼ぶと、芋蔓式に呼び出し側もそれに依存する
- コマンドとクエリは混ぜてはならない
- コンストラクタは副作用を持たないようにし、クエリにする
- クエリ型でも特に決定論的なメソッドを純粋関数と呼び、非決定論的なクエリや副作用のあるコマンドはシステムのエッジに配置する（関数型コア命令型シェル）
- 横断的関心ごとは、経験上デコレーターパターンを使って実装するのが最適である
  - ロギング
  - パフォーマンス監視
  - 監査
  - 計測
  - 計装
  - キャッシング
  - フォールトトレランス
  - セキュリティ
- ロギングでは、問題を再現するための必要十分な情報を残すべき。純粋関数が多ければ多いほど、ロギングは不要になる

### 14. リズム

- IDEが表示する情報をリアルタイムに活用するために、画面を見続けることができるタッチタイピングは重要

### 15. いつもの顔ぶれ

- パフォーマンスを気にするのは、まず動いてから。そしてパフォーマンスを気にしなければならないことを確認して、実測してから、ボトルネックに最適化を行う
- セキュリティはSTRIDEフレームワークで考える

### 16. ナビゲーション

- ソースコードは全て単一のディレクトリに入れる。整理のためだけにサブディレクトリは作らない
