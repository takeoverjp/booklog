# Links

https://www.oreilly.co.jp/books/9784814400416/

# ルール１　できるだけ単純であるべきだが、単純化してはいけない

> 問題の広範な定義に向けた複雑な解法ではなく、問題の本当に解くべき部分に向けた単純な解法がある方が、はるかにマシだ。

そのためには、問題の本質を正確に理解する必要がある。  
「単純化してはいけない」というのは、解くべき問題は解かなければならない、ということ。  
問題の本質を正確に理解し、必要最小限の複雑性で解くべき問題を過不足なく解かなければならない。

> コード内で重複部分の量を減らすことについては、何らかの利点が存在するのは明
らかだ！ でも、重複部分の除去には付随するコストが存在するってのを、認識して
おくことが大事だ。

メンテナンス性と、可読性のトレードオフ。

# ルール２　バグは伝染する

- バグがあると、そのバグに依存するコードや、バグを回避するコードが生まれる。  
  結果、時が立つほど修正に対する依存関係が複雑になり、修正が難しくなる。

- 自動テストには向き不向きがある前提で、自動テストの対象と手動テストの対象を計画しなければならない。

- テストしやすいコードにする
  - 状態を減らす。

- 内部状態の不正、呼び出し前提条件の不正などは、監査して早期に検出する

# ルール３　優れた名前こそ最高のドキュメントである

- コードは書くより読むことの方が多い。タイプ数をケチるな
- コードを読むときの認知的負荷を下げるために、一貫性をもたせる
- 規約の中身はなんでも良いが、一貫性をもたせるため、何も考えず機械的に対応できる規約が良い。充実したドキュメントと、強制する仕組みが重要。

# ルール４　一般化には３つの例が必要

- YAGNI
- 呼び出し元が３個出てきて初めて一般化すべし（３は著者の経験値）
- 不用意に一般化をすると、その後のありとあらゆる拡張をそこに入れることで、肥大化して扱いにくくなる流れを作ってしまう

# ルール５　最適化に関する教訓その１は、「最適化するな」

- 早まった最適化派諸悪の根源である。
- 単純なコードを早くするのは簡単だ
- 最適化手順
  - 測定し、原因を関連付ける
  - バグがないことを確認する
  - 呼び出されるパターンを計測する
  - 対象の箇所を修正することで、全体の性能がどれだけ改善するかを計画し、プロトタイプを作成する
  - 最適化し、繰り返す

# ルール６　コードレビューを良いものにしている３つの理由

- コードレビューをやる理由
  - バグを検出する
    - レビュアーが検出するのではなく、事前準備や対話の中で検出する
  - 知識の共有
  - 人に進んで見せたくなるようなコードをみんなが書く

- 許可よりも許しを請う方がずっといい

# ルール7 失敗が起こる場合をなくす

– 失敗に耐性のあるインターフェースを作るためには早期発見が鍵
- 別々の引数が何らかの形で一致しなければならないことを要求するのは碌でもない
- 引数の多いコンストラクタには、メソッドチェーンやテンプレートの仕組みなどを使うことで、型安全を強制することができる
- ただし、驚き最小の法則に従うよう、一つだけ別のイディオムを使うようなことは避けるべき
- 誤りを検出できるといい、でも誤りをコードとして表現できなければもっといい

# ルール８ 実行されていないコードは動作しない

- 呼び出されなくなった関数は、いずれ必ず動かなくなって、いずれ必ず呼ばれて、わかりにくい不具合になる
- そうならないように、呼び出されなくなった関数は削除しよう
- どうしてももとに戻したくなったら、gitから取り出せばいい（そんなことやらないだろうけど）

# ルール９ 集約可能なコードを書け

- 短期記憶で覚えられるのはせいぜい7個（±2個）
- 適切な名前付けとコメントで、短期記憶の使用量を節約する
- 関数を分けることで理解しやすくなるならわける、そうでないならわけない
- チーム内で共有された、標準的な抽象化やパターンを使うことで、メンバの長期記憶を使うことができ、短期記憶を節約できる

# ルール１０　複雑性を局所化せよ

- 複雑性を局所化することで、複雑性は状態の数に対して線形に増える
- 複雑性が分散していれば、複雑性は状態の数に対して２乗で増加し、すくに管理不可能になる

# ルール１１　２倍良くなるか？

- 作り直すことで２倍良くなるなら作り直す
- そうでなければインクリメンタルに解決していく

# ルール１２　大きなチームには強い規則が必要

- エラーを返す方法
  - true/false（詳細はログ）
  - エラーコード
  - 例外
- ガチガチにコーディング規約をつくり、強制することで、誰のコードでもストレスなく自分のコードのように読めるようにする

# ルール１３　雪崩を起こした小石を探せ

- 対症療法ではなく、真因を特定し直すことで、再発を予防する
- デバッグが難しいと、対症療法で勝利宣言してしまう誘惑に駆られる
- デバッグで原因を特定しやすくするためには、状態を減らして再現を容易にすることが重要である
- 純粋関数であれば、デバッガのstep backが機能し、非常に有用
- 重要な状態であれば、全ての状態の遷移を残しておき、再現できるようにしておくことで、デバッグを容易にする

# ルール１４　コードには種類が4つある

- 4種類
  - 「やさしい問題」、「単純な解法」
  - 「やさしい問題」、「複雑な解法」
  - 「難しい問題」、「単純な解法」
  - 「難しい問題」、「複雑な解法」
- 「やさしい問題」を「複雑な解法」で解くと、無駄にデバッグにかかる時間を延ばしてしまう
- 優秀なプログラマは、「やさしい問題」を「単純な解法」で解く
- 偉大なプログラマは、「難しい問題」を「単純な解法」で解く

# ルール１５　雑草は抜け

- コーディング規約に従っていないコード、不正確なコメントなどは、都度修正する
- 雑草の発見は、チーム内で上級の立場にあるメンバーが最適

# ルール１６　コードから先に進むのではなく、結果から後ろ向きに辿れ

- 技術観点で解法を検討すると、実装するには簡単だが使うには不便な仕様となることがある
- 利用者観点で解法を検討すると、使いやすいだけでなく、単純で優れた解法になる
- エラーはできるだけ早期に検出する
