# links

https://www.oreilly.co.jp//books/9784814400515/

# 1. Rust 並行性の基本

Rustの並行性に絡む要素のおさらい。

- plintlnマクロは出力が混ざらないようにロックを取っている
- スコープ付きスレッドで、ローカル変数をキャプチャできる
- Arcをcloneするときはシャドウイングした方が読みやすい
- 未定義動作は最適化により問題の箇所より前に影響を及ぼす可能性がある
- 共有参照は、内部可変性により特定の条件下で変更可能にできる
- Sendトレイトを満たす型は、他のスレッドに所有権をわたすことができる
- Syncトレイトを満たす型は、別のスレッドと共有できる
- RustのMutexは、ドロップすることでunlockする
- ロックを取得した状態でpanicすると、そのろっくはpoisonedになり、unlockされる。次にlockしたときにErrで知ることができる
- RustのMutexは他の言語と違い保護対象のデータを含んでいる
- ある条件を待つためには、スレッドパーキングと条件変数が使える

# 2. アトミック操作

Rustでのアトミック操作プリミティブについての解説。

- std::sync::atomicによりアトミック操作ができる
- アトミック操作には、load/store、fetch-and-modify(read-modify-write)、compare-and-exchange(compare-and-swap)がある
- storeは値を更新するにもかかわらず、共有参照をとる(内部可変性)
- 遅延初期化が複数回走ることは、データ競合ではなく競合という
- 遅延初期化の競合は、毎回変わるか、どれだけ実行時間がかかるかなどにより、問題となるかどうかが変わる
- アトミック操作のfetch_addなどは、オーバーフロー時にパニックではなくラップすることに注意が必要
- メモリオーダリングがRelaxedの場合、他の変数に対する操作との前後関係が保証されないことに注意が必要
- compare_exchange_weakは、値が一致していてもエラーを返す可能性がある一方で、性能上有利になる
- fetch_updateを使えば、繰り返しを伴うアトミック操作をすっきり記述することができる

# 3. メモリオーダリング

- 命令のリオーダによる最適化は、コンパイラとプロセッサによって行われる可能性がある
  - 逆に、コンパイラの最適化をしない場合や、アセンブリを確認した場合でも、プロセッサによるリオーダの可能性は残るので、メモリオーダリングの設定は必要


- アトミック操作の入れ替え可否を、コンパイラとプロセッサに対して伝える概念がメモリオーダリング
- Rustでは、各アトミック操作に対して、下記のメモリオーダリングが指定できる
  - Relaxed
    - 同一のアトミック変数に対してのみ、順番を保証する
  - Release / Acquire
    - Releaseストアよりも先に起きたことは、Acquireロードよりあとには観測できることを保証する
  - Sequentially Consistent
    - グローバルに一貫した操作順序を保証する
    - ただし、影響が大きいため、コードの意図が不明瞭になる

- フェンスを使うことで、条件付きでメモリオーダリングを設定することができる

# 4. スピンロックの実装

独自のSpinLock型をRustの型システムを使って提供する。

- スピンループヒント(`std::hint::spin_loop()`)を呼び出すことで、プロセッサに対して、何かが変わるのをスピンして待っていることをプロセッサに伝えることができる。
- ロックを共有しつつ、保護対象の変更可能なデータを一緒に保持するためには、`UnsafeCell`で内部可変性を用いる必要がある。
- ロックガードは、ロック状態にあるロックへの安全なアクセスを表現する特別な型を用いた、デザインパターン。
  - [`std::lock_guard` (C++)](https://cpprefjp.github.io/reference/mutex/lock_guard.html)
  - [Scoped Locking Pattern](https://www.dre.vanderbilt.edu/~schmidt/PDF/ScopedLocking.pdf)

# 5. チャネルの実装

いくつかのスレッド間通信チャネルを実装してみる。

- 単純にMutexをとって、queueに追加、取り出しを行うことで、多対多の通信チャネルを実装できる。
  - ただし、広くロックをとるため性能上不利であること、チャネルに無制限に追加できてしまう、といった課題がある。

- ワンショットチャネル
  - `std::mem::MaybeUninit<T>`は、`Option<T>`の、ユーザが手動で初期化済みかどうかを判定しなければならないunsafeバージョン
  - 別途データの有無を`AtomicBool`に持っている場合は、`std::mem::MaybeUninit<T>`を使うことでメモリの浪費を避けることができる
  - 以下の実行時チェックを追加することで、安全なワンショットチャネルにできる
    - メッセージがない状態(=`ready=false`)で`receive`を呼び出したら`panic!`
    - メッセージをすでに読み込んでいる状態(=`ready=false`)で`receive`を呼び出したら`panic!`
    - メッセージをすでに送り始めている状態(=`in_use=true`)で`send`を呼び出したら`panic!`
    - メッセージはあるが、まだ読まれていない状態でchannelがdropしたら、messageもdropする
  - 非Copy型を値渡しするAPIにすることで、１度しか呼び出されないことをコンパイラでチェックできる
  - 利用者側でChannelを確保し、SenderとReceiverにChannelを借用させるAPIにすることで、メモリ確保を最適化する余地を利用者に与えられる（その分便宜性が犠牲になる）
  - 排他借用を２つの共有借用に分割することができる
  - あるオブジェクトが同じスレッドにとどまることを保証するには、マーカ型の`PhantomData`を要素とすることで`Send`を実装しなければよい

# ６．Arcの実装

- プロセスのabortは即時にできるわけではないので、オーバーフローチェックは他の全てのスレッドが同時に動作してもabortするまでの間にオーバーフローしないだけの十分な余地を残してチェックする必要がある
- [miri](https://github.com/rust-lang/miri)を使うことで、unsafeコードの未定義動作やデータ競合を検出することができる。
- weakポインタ (`Weak<T>`)を使うことで循環参照してもリソースを解放することができる
- 複数のアトミック変数を扱う場合、スピンロックが有効な場合がある

# ７．プロセッサを理解する

- x86-64, aarch64において、現状ではload/storeはもともとアトミックに実施される
- とはいえ、Rustのレイヤでアトミックな命令を明示的に指定することは必要である
- x86-64のadd命令は、プロセッサの中でmicroinstructionsに分割されるため、１命令だがアトミックではない
- RISC系のアーキテクチャで使われるLL/SCでは、他のスレッドがメモリ領域を上書きしていたらストアを拒否する
- ストアに失敗した場合、再実行することによってアトミックなストアを実現できるが、LL/SC間の命令数が多くなると、ループが稀にしか成功しなくなり破綻する
- aarch64では途中でCISCタイプのアトミック命令が追加された。LL/SCは非常に柔軟だが、CISCタイプの方がプロセッサの性能を最適化しやすいため
- `std::hint::black_box`を使うことで、最適化を避けることができる

- 命令リオーダ
  - 非アトミック操作とRelaxedなアトミック操作は、どのような命令リオーダも許容する
  - Sequentially Consistentなアトミック操作は、全く命令リオーダを許容しない
  - Acquire操作は、後続するメモリ操作と入れ替えてはならない
    - lockを取ってからメモリにアクセスすることを保証するため
  - Release操作は、先行するメモリ操作と入れ替えてはならない
    - メモリにアクセスしてからlockを解放することを保証するため

- x86-64：強く順序付けされたアーキテクチャ
  - x86-64はAcquireロード・Releaseストアの要件をはじめから満たしているので、Release/Acquireをただで利用できる
- ARM64：弱く順序付けされたアーキテクチャ
  - 全てのメモリ操作が潜在的には相互に入れ替えられる可能性がある
- 以上のことより、x86-64ではたまたま完全に動作するが、ARM64では未定義動作をするプログラムがありえる
