# links

https://www.oreilly.co.jp//books/9784814400515/

# 1. Rust 並行性の基本

Rustの並行性に絡む要素のおさらい。

- printlnマクロは出力が混ざらないようにロックを取っている
- スコープ付きスレッドで、ローカル変数をキャプチャできる
- Arcをcloneするときはシャドウイングした方が読みやすい
- 未定義動作は最適化により問題の箇所より前に影響を及ぼす可能性がある
- 共有参照は、内部可変性により特定の条件下で変更可能にできる
- Sendトレイトを満たす型は、他のスレッドに所有権をわたすことができる
- Syncトレイトを満たす型は、別のスレッドと共有できる
- RustのMutexは、ドロップすることでunlockする
- ロックを取得した状態でpanicすると、そのろっくはpoisonedになり、unlockされる。次にlockしたときにErrで知ることができる
- RustのMutexは他の言語と違い保護対象のデータを含んでいる
- ある条件を待つためには、スレッドパーキングと条件変数が使える

# 2. アトミック操作

Rustでのアトミック操作プリミティブについての解説。

- std::sync::atomicによりアトミック操作ができる
- アトミック操作には、load/store、fetch-and-modify(read-modify-write)、compare-and-exchange(compare-and-swap)がある
- storeは値を更新するにもかかわらず、共有参照をとる(内部可変性)
- 遅延初期化が複数回走ることは、データ競合ではなく競合という
- 遅延初期化の競合は、毎回変わるか、どれだけ実行時間がかかるかなどにより、問題となるかどうかが変わる
- アトミック操作のfetch_addなどは、オーバーフロー時にパニックではなくラップすることに注意が必要
- メモリオーダリングがRelaxedの場合、他の変数に対する操作との前後関係が保証されないことに注意が必要
- compare_exchange_weakは、値が一致していてもエラーを返す可能性がある一方で、性能上有利になる
- fetch_updateを使えば、繰り返しを伴うアトミック操作をすっきり記述することができる

# 3. メモリオーダリング

- 命令のリオーダによる最適化は、コンパイラとプロセッサによって行われる可能性がある
  - 逆に、コンパイラの最適化をしない場合や、アセンブリを確認した場合でも、プロセッサによるリオーダの可能性は残るので、メモリオーダリングの設定は必要


- アトミック操作の入れ替え可否を、コンパイラとプロセッサに対して伝える概念がメモリオーダリング
- Rustでは、各アトミック操作に対して、下記のメモリオーダリングが指定できる
  - Relaxed
    - 同一のアトミック変数に対してのみ、順番を保証する
  - Release / Acquire
    - Releaseストアよりも先に起きたことは、Acquireロードよりあとには観測できることを保証する
  - Sequentially Consistent
    - グローバルに一貫した操作順序を保証する
    - ただし、影響が大きいため、コードの意図が不明瞭になる

- フェンスを使うことで、条件付きでメモリオーダリングを設定することができる

# 4. スピンロックの実装

独自のSpinLock型をRustの型システムを使って提供する。

- スピンループヒント(`std::hint::spin_loop()`)を呼び出すことで、プロセッサに対して、何かが変わるのをスピンして待っていることをプロセッサに伝えることができる。
- ロックを共有しつつ、保護対象の変更可能なデータを一緒に保持するためには、`UnsafeCell`で内部可変性を用いる必要がある。
- ロックガードは、ロック状態にあるロックへの安全なアクセスを表現する特別な型を用いた、デザインパターン。
  - [`std::lock_guard` (C++)](https://cpprefjp.github.io/reference/mutex/lock_guard.html)
  - [Scoped Locking Pattern](https://www.dre.vanderbilt.edu/~schmidt/PDF/ScopedLocking.pdf)

# 5. チャネルの実装

いくつかのスレッド間通信チャネルを実装してみる。

- 単純にMutexをとって、queueに追加、取り出しを行うことで、多対多の通信チャネルを実装できる。
  - ただし、広くロックをとるため性能上不利であること、チャネルに無制限に追加できてしまう、といった課題がある。

- ワンショットチャネル
  - `std::mem::MaybeUninit<T>`は、`Option<T>`の、ユーザが手動で初期化済みかどうかを判定しなければならないunsafeバージョン
  - 別途データの有無を`AtomicBool`に持っている場合は、`std::mem::MaybeUninit<T>`を使うことでメモリの浪費を避けることができる
  - 以下の実行時チェックを追加することで、安全なワンショットチャネルにできる
    - メッセージがない状態(=`ready=false`)で`receive`を呼び出したら`panic!`
    - メッセージをすでに読み込んでいる状態(=`ready=false`)で`receive`を呼び出したら`panic!`
    - メッセージをすでに送り始めている状態(=`in_use=true`)で`send`を呼び出したら`panic!`
    - メッセージはあるが、まだ読まれていない状態でchannelがdropしたら、messageもdropする
  - 非Copy型を値渡しするAPIにすることで、１度しか呼び出されないことをコンパイラでチェックできる
  - 利用者側でChannelを確保し、SenderとReceiverにChannelを借用させるAPIにすることで、メモリ確保を最適化する余地を利用者に与えられる（その分便宜性が犠牲になる）
  - 排他借用を２つの共有借用に分割することができる
  - あるオブジェクトが同じスレッドにとどまることを保証するには、マーカ型の`PhantomData`を要素とすることで`Send`を実装しなければよい

# ６．Arcの実装

- プロセスのabortは即時にできるわけではないので、オーバーフローチェックは他の全てのスレッドが同時に動作してもabortするまでの間にオーバーフローしないだけの十分な余地を残してチェックする必要がある
- [miri](https://github.com/rust-lang/miri)を使うことで、unsafeコードの未定義動作やデータ競合を検出することができる。
- weakポインタ (`Weak<T>`)を使うことで循環参照してもリソースを解放することができる
- 複数のアトミック変数を扱う場合、スピンロックが有効な場合がある

# ７．プロセッサを理解する

- x86-64, aarch64において、現状ではload/storeはもともとアトミックに実施される
- とはいえ、Rustのレイヤでアトミックな命令を明示的に指定することは必要である
- x86-64のadd命令は、プロセッサの中でmicroinstructionsに分割されるため、１命令だがアトミックではない
- RISC系のアーキテクチャで使われるLL/SCでは、他のスレッドがメモリ領域を上書きしていたらストアを拒否する
- ストアに失敗した場合、再実行することによってアトミックなストアを実現できるが、LL/SC間の命令数が多くなると、ループが稀にしか成功しなくなり破綻する
- aarch64では途中でCISCタイプのアトミック命令が追加された。LL/SCは非常に柔軟だが、CISCタイプの方がプロセッサの性能を最適化しやすいため
- `std::hint::black_box`を使うことで、最適化を避けることができる

- 命令リオーダ
  - 非アトミック操作とRelaxedなアトミック操作は、どのような命令リオーダも許容する
  - Sequentially Consistentなアトミック操作は、全く命令リオーダを許容しない
  - Acquire操作は、後続するメモリ操作と入れ替えてはならない
    - lockを取ってからメモリにアクセスすることを保証するため
  - Release操作は、先行するメモリ操作と入れ替えてはならない
    - メモリにアクセスしてからlockを解放することを保証するため

- x86-64：強く順序付けされたアーキテクチャ
  - x86-64はAcquireロード・Releaseストアの要件をはじめから満たしているので、Release/Acquireをただで利用できる
- ARM64：弱く順序付けされたアーキテクチャ
  - 全てのメモリ操作が潜在的には相互に入れ替えられる可能性がある
- 以上のことより、x86-64ではたまたま完全に動作するが、ARM64では未定義動作をするプログラムがありえる

# ８．OSプリミティブ

- pthreadが提供するAPIは、Cのために設計されていて、Rustから使用するのには向かない
  - 各変数の移動可能性が保証されていない
  - 移動可能性を保証するため、各変数を`Box`に保持すると、全てヒープに確保されるのでオーバーヘッドが発生する
  - 再帰的ロックを妨げる安全なインターフェースを設計することができず、未定義動作になる
  - ロックされた`Mutex`がドロップされたときにも未定義動作になる
- Linuxには`SYS_futex`というシステムコールが提供されている
- `SYS_futex`を使うことで、32bitのアトミック整数に対して、pthreadよりもはるかに柔軟に操作できる
- Futex操作には、優先度継承(Priority Inheritance)に対応した、`_PI`操作が用意されている。
  - この場合、渡すアトミック変数の値からカーネルがロックしているスレッドの情報がわかるように、tidを含む情報を入れる
- macOS/Windowsでは、カーネルインターフェースは安定しておらず、直接使うことは想定されていない
- c++20においてもfutexに類似した基本的な操作が標準ライブラリに追加されている（`atomic_wait`, `atomic_notify`）

# 9. ロックの実装

- atomic-waitクレートを使うことで、futex相当の操作をOS非依存で実装することができる
- atomic-waitクレートを使い、Mutex、条件変数、リーダ・ライタロックを実装する
- いずれの実装においても、システムコールの呼び出し回数を低減することが性能最適化につながる
- Mutexの場合、大気中のスレッドがあるかどうかを、ユーザ空間で管理することで、システムコールを減らすことができる
- 条件変数の場合、偽の待機解除を避ける、という最適化の方向もある
- リーダ・ライタロックの場合、ライタ・スタベーション（リーダがロックを取りすぎてライタがロックを取れない状態）を防ぐ、という最適化の方向もある
  - ライタが待機していたら、新しいリーダはロックを取得できないようにする手法がある

# 10. アイディアとインスピレーション

- RCU
  - コンピュータサイエンスの全ての問題は、間接参照のレイヤを追加することで解決できる
  - 多数のフィールドをもつ構造体に対して、atomicに操作したい場合、構造体へのポインタを保持するアトミック変数を使うことで、ロックフリーなアトミック操作が可能になる
  - このパターンは、Read, Copy, Updateの頭文字をとって、RCUと呼ばれる
  - Linuxカーネルの中の多くのデータ構造がRCUベースで実装されている
  - [リード・コピー・アップデート](https://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%BC%E3%83%89%E3%83%BB%E3%82%B3%E3%83%94%E3%83%BC%E3%83%BB%E3%82%A2%E3%83%83%E3%83%97%E3%83%87%E3%83%BC%E3%83%88)
  - [What is RCU, Fundamentally?](https://lwn.net/Articles/262464/)

- キューベースロック
  - 大気中のスレッドのキューを手動で管理することで、Mutexを実装する手法
  - 待機スレッドのリストを指すAtomicPtrで実装できる

- パーキングロットベースロック
  - キューベスロックをベースにキューをグローバルに保持することで、Mutexを可能な限り小さくすることができる
  - パーキングしているスレッドの集まりであることから、グローバルなキューのことをパーキングロット（駐車場）と呼ぶ

- シーケンスロック
  - ライタは、カウンタを読み込みインクリメントし、データの書き出しをして、再度カウンタをインクリメントする
  - リーダは、カウンタを読み込み、データを読み込み、再度カウンタを読み込む。カウンタが更新されていたらやり直し
  - Linuxカーネルでは、タイムスタンプを効率的にプロセスに提供するために、このパターンが使用されている
