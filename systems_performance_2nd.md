# Links

https://www.oreilly.co.jp/books/9784814400072/

- [bpftrace 2020 - 睡分不足](https://mmi.hatenablog.com/entry/2020/12/02/031534#%E6%9C%80%E5%BE%8C%E3%81%AB---bpftrace%E3%81%AB%E9%96%A2%E3%82%8F%E3%81%A3%E3%81%A6%E3%81%8D%E3%81%A6)
- [bpftrace/docs/tutorial_one_liners_japanese.md at master · iovisor/bpftrace](https://github.com/iovisor/bpftrace/blob/master/docs/tutorial_one_liners_japanese.md)
- [バグ調査やパフォーマンス改善に役立つ！eBPFを用いたトレーシングについて | さくらのナレッジ](https://knowledge.sakura.ad.jp/24486/)

# 用語集

- IOPS
  - 1秒あたりのI/Oオペレーション。データ転送オペレーションのスピードの指標。ディスクI/Oでは、1秒あたりの読み書きの回数
- スループット
  - 仕事が実行されるスピード。特に通信では、データ転送速度（１秒あたりのバイト数 or ビット数）。コンテキストによっては、処理速度（１秒あたりのオペレーション数 or トランザクション数）
- 応答時間
  - オペレーションが完了するまでの時間。実行待ち、実処理、結果の転送などすべてにかかった時間を含む
- レイテンシ
  - オペレーションがサービスの提供を待つために使った時間。コンテキストによっては、応答時間と同じ意味で使われる。
- 使用率
  - 与えられたインターバルのうちアクティブに作業をしていた時間がどれだけかに基づいて、リソースがどの程度ビジーかを計測した値。例えば、メモリの使用率など。
- 飽和度
  - リソースがキューイング下作業のうち、サービスを提供できていないものの割合
- ボトルネック
  - システムのパフォーマンスに限界を与えているリソースのこと
- ワークロード
  - システムに対する入力、またはシステムにかけられる負荷

# 1. イントロダクション

- 分析の視点には、アプリケーション開発者観点のワークロード分析と、システム管理者観点のリソース分析がある

- 観測手法には下記がある
  - カウンタ、統計量、指標
    - 例：procfs, vmstat
  - プロファイリング
    - 例：CPUプロファイリングとして、一定間隔ごとにon-CPUのコードパスをサンプリングする
  - トレーシング
    - 静的インストルメンテーション
      - 例
        - Linux kernelが予め用意したトレースポイント
        - USDT (user statically defined tracing)
        - `execsnoop(8)`を使うことで、どのようなコマンドのexecを実施したかを確認できる
          - topのようなサンプリングとは異なり、短時間で終了するプロセスの情報も収集できる
    - 動的インストルメンテーション
      - 例：kprobe, eBPF, perf, ftrace

###  1.10.1 **60秒で終わるLinuxパフォーマンス分析**

```
# load average
$ uptime
 21:45:14 up 22:03,  2 users,  load average: 0.68, 0.44, 0.23
```

```
# OOMなどのkernel error
$ dmesg -T | tail
```

```
# 欄キュー、スワップ、CPU使用率などのシステムレベルの統計量
$ vmstat -SM 1
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 4  0      0  24069    136   5275    0    0    27    79  410    1  1  0 98  0  0
 2  0      0  24080    136   5278    0    0     0     0  654 1608  3  1 97  0  0
 1  0      0  24092    136   5274    0    0     0    28  392 1001  1  0 99  0  0
```

```
# CPU間のバランス。特定のCPUに負荷が偏っていないか
$ mpstat -P ALL 1
Linux 6.2.0-33-generic (biwa)   2023年10月05日  _x86_64_        (8 CPU)

21時49分16秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
21時49分17秒  all    2.26    0.00    1.13    0.00    0.00    0.00    0.00    0.00    0.00   96.61
21時49分17秒    0    1.02    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   98.98
21時49分17秒    1    2.02    0.00    1.01    0.00    0.00    0.00    0.00    0.00    0.00   96.97
21時49分17秒    2    3.00    0.00    2.00    0.00    0.00    0.00    0.00    0.00    0.00   95.00
21時49分17秒    3    5.00    0.00    2.00    0.00    0.00    0.00    0.00    0.00    0.00   93.00
21時49分17秒    4    1.01    0.00    1.01    0.00    0.00    0.00    0.00    0.00    0.00   97.98
21時49分17秒    5    2.97    0.00    0.99    0.00    0.00    0.00    0.00    0.00    0.00   96.04
21時49分17秒    6    2.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   98.00
21時49分17秒    7    1.00    0.00    2.00    0.00    0.00    0.00    0.00    0.00    0.00   97.00
```

```
# プロセスごとのCPU使用状況と、ユーザ/システムCPU時間の内訳
$ pidstat 1
Linux 6.2.0-33-generic (biwa)   2023年10月05日  _x86_64_        (8 CPU)

21時49分44秒   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
21時49分45秒  1000      1026    0.96    0.00    0.00    0.00    0.96     3  gnome-shell
21時49分45秒  1000      1394    0.96    0.00    0.00    0.00    0.96     7  ibus-daemon
21時49分45秒  1000      1500    0.96    0.00    0.00    0.00    0.96     4  Xwayland
21時49分45秒  1000      1663    0.96    0.00    0.00    0.00    0.96     1  ibus-engine-moz
21時49分45秒  1000      1795    0.96    0.00    0.00    0.00    0.96     5  ibus-x11
21時49分45秒  1000      2176    0.96    0.96    0.00    0.00    1.92     7  code
21時49分45秒  1000      2211    1.92    0.96    0.00    0.00    2.88     2  code
21時49分45秒  1000      2243    4.81    0.00    0.00    0.00    4.81     5  code
21時49分45秒  1000      2894    0.96    0.96    0.00    0.00    1.92     2  code
21時49分45秒  1000      8706    0.00    0.96    0.00    0.00    0.96     4  chrome
21時49分45秒  1000     33476    0.96    0.96    0.00    0.00    1.92     4  pidstat
```

```
# ディスクIO統計：IOPS, スループット、平均待ち時間、ビジー状態の割合など
$ iostat -sxz 1
Linux 6.2.0-33-generic (biwa)   2023年10月05日  _x86_64_        (8 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           1.16    0.01    0.38    0.16    0.00   98.30

Device             tps      kB/s    rqm/s   await  areq-sz  aqu-sz  %util
loop0             0.00      0.00     0.00    0.00     1.00    0.00   0.00
loop1             0.00      0.00     0.00    0.09     1.09    0.00   0.00
loop10            0.00      0.00     0.00    0.09     9.81    0.00   0.00
loop11            0.00      0.00     0.00    0.00     1.27    0.00   0.00
loop2             0.00      0.05     0.00    0.13    11.22    0.00   0.00
loop3             0.00      0.00     0.00    0.07     1.86    0.00   0.00
loop4             0.02      0.26     0.00    0.11    11.87    0.00   0.00
loop5             0.00      0.00     0.00    0.22     1.56    0.00   0.00
loop6             0.01      0.07     0.00    0.03     9.68    0.00   0.00
loop7             0.00      0.00     0.00    0.07     1.79    0.00   0.00
loop8             0.00      0.00     0.00    0.14     8.09    0.00   0.00
loop9             0.01      0.28     0.00    0.13    36.44    0.00   0.00
nvme0n1           5.67  11898.95     3.18    8.94  2097.69    0.06   1.25
sda               0.00      0.05     0.00    0.21    25.43    0.00   0.00


avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           2.27    0.00    0.50    0.00    0.00   97.23

Device             tps      kB/s    rqm/s   await  areq-sz  aqu-sz  %util


avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           1.00    0.00    0.50    0.12    0.00   98.38

Device             tps      kB/s    rqm/s   await  areq-sz  aqu-sz  %util
nvme0n1           2.00     24.00     4.00    1.50    12.00    0.00   0.40
```

```
# ファイルシステムキャッシュを含むメモリ使用状況
$ free -m
               total        used        free      shared  buff/cache   available
Mem:           31956        4283       23989        1339        5493       27672
Swap:           8191           0        8191
```

```
# ネットワークデバイスI/O。パケットとスループット
$ sar -n DEV 1
Linux 6.2.0-33-generic (biwa)   2023年10月05日  _x86_64_        (8 CPU)

21時52分27秒     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
21時52分28秒        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
21時52分28秒      eno1      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
21時52分28秒 wlp0s20f3      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00

21時52分28秒     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
21時52分29秒        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
21時52分29秒      eno1      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
21時52分29秒 wlp0s20f3      5.00      4.00      0.51      2.71      0.00      0.00      0.00      0.00
```

```
# TCP統計。接続のスピード、再送
$ sar -n TCP,ETCP 1
Linux 6.2.0-33-generic (biwa)   2023年10月05日  _x86_64_        (8 CPU)

21時52分45秒  active/s passive/s    iseg/s    oseg/s
21時52分46秒      0.00      0.00      0.00      0.00

21時52分45秒  atmptf/s  estres/s retrans/s isegerr/s   orsts/s
21時52分46秒      0.00      0.00      0.00      0.00      0.00

21時52分46秒  active/s passive/s    iseg/s    oseg/s
21時52分47秒      1.00      0.00      0.00      1.00

21時52分46秒  atmptf/s  estres/s retrans/s isegerr/s   orsts/s
21時52分47秒      0.00      0.00      0.00      0.00      0.00
```

```
# 全体的なチェック
$ top
```

- `offcputime`(8)を使えば、off-CPUで過ごした時間の情報を取り出すことができる。
  - off-CPUとは、IOやlock, timer, paging/swapping街などにより、CPUを使わずに消費している時間のこと
  - 参考：https://www.brendangregg.com/offcpuanalysis.html

# 2. メソドロジ

## 2.3. コンセプト
### 2.3.1 レイテンシ

- 単に「レイテンシ」というと曖昧になるので、要求レイテンシ、TCP接続レイテンシのように、何を計測にしているかを明らかにすること

### 2.3.2 タイムスケール

| operation                           | latency  |
| ----------------------------------- | -------- |
| 1CPUサイクル                        | 0.3ns    |
| L1 cache                            | 0.9ns    |
| L2 cache                            | 3ns      |
| L3 cache                            | 10ns     |
| DRAM from CPU                       | 100ns    |
| SSD I/O (flash)                     | 10-100us |
| 回転ディスクI/O                     | 1-10ms   |
| Internet (SanFrancisco - NewYork)   | 40ms     |
| Internet (SanFrancisco - England)   | 81ms     |
| Internet (SanFrancisco - Australia) | 183ms    |

### 2.3.10 パフォーマンス指標

- 観測者効果
  - パフォーマンス指標を収集・格納するためにかかｒオーバーヘッドのこと
- 問題点
  - パフォーマンス指標は、誤解を招きやすく、複雑で、信頼性が低く、不正確で、単純に間違っていることさえある。

### 2.3.14 キャッシング

- アルゴリズム
  - MRU (Most Recently Used) = LRU (Least Recently Used)
  - MFU (Most Frequently Used) = LFU (Least Frequently Used)

## 2.5 メソドロジ

### 2.5.4 アドホックチェックリストメソッド

- 場当たり的なチェックリストでも、よくある問題のチェック方法を全員に周知徹底するための方法として効果的
- チェックリストは、ここの問題の見分け方と、解決方法を明確に処方箋的に書くと良い
- ただし、リストは絶えず更新しなければならない

### 2.5.5 問題の記述

- 問題をレポートする時点でヒアリングする項目を明確にしておく
  - パフォーマンスに問題があると思ったのはなぜか
  - 対象のシステムが、良好なパフォーマンスで動いていたことがあったのか、
  - 最近の変化はなにか？（ソフト・ハード・負荷）
  - その問題は、レイテンシか実行時間で表現できるか
  - その問題は、他の人やアプリケーションに影響を及ぼしているか
  - 環境はどうなっているのか。（ソフトのバージョン・ハードのバージョン・構成）

### 2.5.6 科学的メソッド

- 下記のステップで改善を検討する
  - 問題
  - 仮設
  - 予測
  - 検証
  - 分析

### 2.5.9 USEメソッド

- すべてのリソースに対して、USE (使用率、飽和度、エラー)をチェックする
- パフォーマンス調査の初期の段階で使うべきメソドロジ
- 調べるべき問の完全なリストが作りやすく、問に答えられるツールが見つからなくても、Known-Unknownsになるので極めて役に立つ

- 用語定義
  - リソース
    - 物理サーバのすべての機能的なコンポーネント（CPU, メインメモリ、ネットワークインターフェース、ストレージ、アクセラレータ、コントローラ、インターコネクト, ...）
    - ソフトウェアリソース（ミューテックスのロック、スレッドプール、プロセス・スレッドの数、ファイルディスクリプタの数）も意味があるのであれば対象として良い
  - 使用率
    - 決められたインターバルの中で、リソースが要求を処理するためにビジー状態だった時間
  - 飽和度
    - 処理できない要求を抱えている度合い（キューで待機している状態など）
  - エラー
    - エラーイベントの回数

### 2.5.15 イベントトレーシング

- `tcpdump(8)`: ネットワーク
- `biosnoop(8)`: ブロックデバイスレイヤのストレージデバイスI/O
- `strace(1)`, `perf(1)`の`trace`サブコマンド: システムコール

### 2.5.20 パフォーマンスマントラ

- パフォーマンスをうまく上げる方法を示す、**チューニングメソドロジ**

1. するな：不要な仕事を取り除く
2. してもいいが二度するな：キャッシング
3. 減らせ：リフレッシュ、ポーリングの頻度を下げる
4. 先に伸ばせ：ライトバックキャッシング
5. 見られていないときにせよ：ピーク時間を外して実行する
6. 同時並行でせよ：シングルスレッドからマルチスレッド
7. 安上がりにせよ：より高速なハードウェアの購入

## 2.6 モデリング

### 2.6.3 スケーラビリティに関するアムダールの法則

- 並列化によってスケーリングしないシリアルコンポーネントを計算に入れたシステムのスケーラビリティのモデル
- アムダール定数α（`0<=α<=1`）は、どれぐらいシリアルかを表し、これが大きければ大きいほど線形スケーラビリティから離れる
- アムダール定数αは、回帰分析で求める
- C(N)は相対的な処理能力
- NはCPU数などのスケーリングするパラメータ

```
C(N) = N/(1 + α(N-1))
```

### 2.6.4 ユニバーサルスケーラビリティ法則

- アムダールの法則にコヒーレンスによる遅れのためのパラメータを追加したモデル
- 下記の通り、コヒーレンスパラメータβが導入されている

```
C(N) = N/(1 + α(N-1) + βN(N-1))
```

### 2.6.5 待ち行列理論

- ケンドールの記法
  - A/S/m
  - A: 到着過程
  - S: サービス時間分布
  - m: サービス線多数
  - 例
    - M/M/1: マルコフ過程の到着時間・サービス時間、サービスセンターが一つ
    - M/D/1: マルコフ過程の到着時間、決定論的（一定）サービス時間、サービスセンターが一つ

## 2.10 ビジュアライゼーション

- 折れ線グラフ
  - 中央値、平均、標準偏差、パーセンタイルを表示することで、データの分布についての詳しい情報を示すこともできる
- 散布図
  - サンプル数が多すぎると、分解能が問題となり得る
- ヒートマップ
  - 散布図のx, y軸の一定の範囲をバケットと呼ばれるグループに量子化して、色の濃さでイベントの数を示す
  - 散布図の分解能の問題が解決する
- タイムライン図
  - ブラウザの開発ツールで、ネットワーク要求の時間関係を示すために広く使われている
  - サーバ側でも、KernelSharkやTraceCompassなどで使われている
- 表面プロット
  - ３次元データを３次元サーフェスにレンダリングして示す
  - データが頻繁に大きく変動しないときにもっとも効果的

# 3. オペレーティングシステム

## 3.2 基礎知識

### 3.2.2 カーネルモードとユーザモード

- システムコールにおける、モードスイッチとコンテキストスイッチのオーバーヘッドを避ける方法
  - ユーザーモードシステムコール
    - ユーザーモードライブラリだけで実装したシステムコール
    - Linuxにおいては、`gettimeofday(2)`, `getcpu(2)`などのいくつかのシステムコールが、頻度が高く特権も不要とのことでこの方式で実装されている
    - vDSO (virtual dyanmic shared object)という仕組みでプロセスexec時にプロセスのメモリ空間に自動的にマッピングされる実態のない共有ライブラリ(linux-vdso.so`等)を、libcが呼び出すことで実現している
      - 参考
        - [vdso(7) - Linux manual page](https://man7.org/linux/man-pages/man7/vdso.7.html)
        - [Implementing virtual system calls [LWN.net]](https://lwn.net/Articles/615809/)
  - メモリマッピング
    - 都度ファイルディスクリプタに対してread/writeするのではなく、メモリにマップしたファイルに対してread/writeすることで、システムコール呼び出し回数を減らすことができる
    - 参考：[高速化に効くシステムコールが犠牲にするもの：知ってトクするシステムコール（4）（2/2 ページ） - ＠IT](https://atmarkit.itmedia.co.jp/ait/articles/1202/21/news133_2.html)
      - `bash`の`time`ではなく、`time`コマンドを使うことで、物理メモリサイズやページフォールト回数、コンテキストスイッチの回数を調べることができる
  - カーネルバイパス
    - ネットワークにおけるDPDK (Data Plane Development Kit)
      - Userspace I/Oを使い、Kernelの管理外でパケット送受信を実現する仕組み
  - カーネルモードアプリケーション
    - ユーザーモードシステムコールの逆の発想で、カーネルモードでアプリケーションの処理を実行する
    - LinuxにおけるeBPF

### 3.2.4 割り込み

- CPUに割り込み信号が入力されると、カーネルモードに入り、現在のスレッドの状態を保存してから、ISR(Interrupt Service Routine)を実行する

- 非同期割り込み：外部のハードウェアが生成する割り込み。ディスクデバイスのI/O完了通知や、入力デバイスの入力通知など。
- 同期割り込み：ソフトウェアの命令が生成する割り込み。例外や、ページフォールトなど。

- 割り込まれる処理への影響を極力抑えるため、ISRは可能な限り高速に実行される
- Linuxのデバイスドライバにおいては、top-halfとbottom-halfに処理が別れており、top-halfは割り込み禁止モードで動作しその場で実施しなければならない最低限の処理だけを実施、bottom-halfはタスクれっとかワークキューにスケジューリングされ、後ほど必要な処理を実施する、という設計になっている。
- 割り込みに対する応答性のために、割り込み禁止期間はできる限り短くなければならない
  - ftraceのirqsoffトレーサなどで分析できる
- 優先度の高いイベントは、マスク不能割り込み(NMI, Non-Maskable Interrupt)にすることができる
  - 例えば、ウォッチドック検出用の割り込みなど

### 3.4.2 systemd

- `systemd-analyze(1)`コマンドで、ブート時間を確認できる
- `systemd-analyze critical-chain`によって、起動のレイテンシの原因となったサービスの内訳を確認することができる

### 3.4.4 拡張BPF

- BPFはカーネルモードで実行される仮想マシン
- ソケットイベント、トレースポイント、USDT(User Statically-Defined Tracking)プローブ、kprobe, uprobe, perf_eventなどのイベントが発生したときに実行される
- BPFバイトコードは、カーネルをクラッシュさせたり壊したりしない安全性を持つことを確認する検証器のチェックをパスしなければならない

## 3.5 その他の項目

### 3.5.1 PGOカーネル

- PGO (Profile-guided optimization)とは、CPUプロファイルを使って、コンパイラの最適化を向上する技術のこと
- 一度本番稼働中にCPUプロファイルをとり、その結果に基づいて再コンパイルすることで、実ユースケースにおいてパフォーマンスを向上することができる
- GCC, Clang, Linux kernelはPGOをサポートしている
- 別名FDO (Feedback-directed optimization)

# 4. 可観測性ツール
- ![一覧](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQicFPsx1gRi85rof0-DEYZdNCFv8p_4iw2tw&usqp=CAU)
- sarはSystem Activity Reporterの頭文字
- 
